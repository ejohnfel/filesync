#!/usr/bin/python3.8
import io
import os
import gzip
import sys
import datetime
import random
import string
import shutil
import subprocess
import argparse
import re
import cmd
import shlex
import locale
import collections

from py_helper import CmdLineMode,DebugMode,Msg,DbgMsg,ErrMsg,Touch,TmpFilename,GetMD5Hash
import py_helper as ph

import redis

"""
Index format
Last_Mod_Timestamp last_size_in_bytes md5hash filename

Master Index Format
Same as Index format, except, the start of each added index includes a index marker of the following format.

from [start|end] path_where_index_came_from
"""

IndexEntry = collections.namedtuple('IndexEntry',["timestamp","size","hash","filename"])

#
# Preamble - Variables and Constants
#

random.seed()

# Parser
parser = None

# Old Stuff
VERMAJ="0"
VERMIN="2ep"
HASENTRYVERSION=2
TIMESTAMPFORMAT="%c"
TIMESTAMP=datetime.datetime.now().strftime(TIMESTAMPFORMAT)
ACCESSDENIEDLOG="/tmp/md5index.access.denied"
VERBOSE=False
FOLDERINDEX=".md5index.gz"
MODE="search"
SILENT=False
SHELLMODE=False
REMOVEFLAG=False
DEPTH=-1
BUILDINDEX=0
TMPCACHE="/tmp/md5index.tmp.cache." + str(random.randint(0,65535))
CACHE="/tmp/md5index.cache"
IGNORECACHE=False

# Redis Stuff
objRedis = None
redisHost="127.0.0.1"
redisPort=6379
redisDB=127

excludes = [ FOLDERINDEX, ".git", ".compiz", ".config", ".dbus", ".gconf", ".gnome2", ".gnome2_private", ".gvfs", ".hplip", ".local", ".salt", ".ssh", "System Volume Information", r"lost+found", r"$RECYCLE.BIN" ]
patterns = [ ]

# Command Shell
cmdshell = None

#
# Lambdas
#

# Lambda for File Exists
Exists = lambda filename: os.path.exists(filename)
# Lambda for Printing version out
ShowVersion = lambda: Msg(f"Version {VERMAJ}.{VERMIN}")

'''
Classes
'''

# Interactive Index Shell Class
class IndexShell(cmd.Cmd):
        intro = 'Welcome to the md5index Shell. Type help or ? for help\n'
        prompt = '> '
        file = None

        # Folder Indexes
        FolderIndex = ".md5index.gz"

        # Cache file
        Cachefile = "/tmp/md5index.cache"

        # Time Stamp Format
        TimeStampFormat = "%c"

        # Silent Flag
        Silent = False

        # Verbose Flag
        Verbose = False

        # Depth Limit
        Depth = -1

        # Argument parsers
        parsers = dict()

        # Excludes
        excludes = list()

        # Patterns, Expressions
        patterns = list()

        # Access Denied Log
        access_denied_log = None
        
        '''
        Functions
        search indexes [folder]
        search index [folder]
        dup [folder]
        exclude str [string]|exclude file [file]
        re ex [re]|re file [file]
        debug on|off
        silent on|off
        '''

        def __init__(self,excludes=None,patterns=None):
                """Initialize Instance"""

                self.__LoadFile__(excludes,self.excludes)
                self.__LoadFile__(patterns,self.patterns)

                # Create Indexes Parser
                parser = argparse.ArgumentParser(description="Create indexes")
                parser.add_argument("operation",choices=["index","indexes","cache"],help="Thing to create")
                parser.add_argument("folders",nargs=argparse.REMAINDER,help="Folder(s) to work on")
                self.parsers["create"] = parser
                # Update Indexes Parser
                parser = argparse.ArgumentParser(description="Update Indexes")
                parser.add_argument("operation",choices=["index","indexes","cache"],help="Thing to update")
                parser.add_argument("folders",nargs=argparse.REMAINDER,help="Folder(s) to work on")
                self.parsers["update"] = parser
                # Delete Indexes Parser
                parser = argparse.ArgumentParser(description="Remove Indexes")
                parser.add_argument("operation",choices=["index","indexes","cache"],help="Thing to remove")
                parser.add_argument("folders",nargs=argparse.REMAINDER,help="Folder(s) to work on")
                self.parsers["remove"] = parser
                # List Indexes Parser
                parser = argparse.ArgumentParser(description="List Indexes")
                parser.add_argument("operation",choices=["index","indexes"],help="Thing to list")
                parser.add_argument("folders",nargs=argparse.REMAINDER,help="Folder(s) to work on")
                self.parsers["list"] = parser
                # Find Indexes Parser
                parser = argparse.ArgumentParser(description="Find Indexes")
                parser.add_argument("operation",choices=["index","indexes"],help="Thing to list")
                parser.add_argument("folders",nargs=argparse.REMAINDER,help="Folder(s) to work on")
                self.parsers["find"] = parser
                # Search Indexes Parser
                parser = argparse.ArgumentParser(description="Search Indexes")
                parser.add_argument("operation",choices=["index","indexes","cache"],help="Thing to search through")
                parser.add_argument("fieldtype",choices=["all","date","folder","name","md5","checksum"],help="Field to search")
                parser.add_argument("searchfor",help="String or regular expression to search for, dates will be converted")
                parser.add_argument("folders",nargs=argparse.REMAINDER,help="Folder(s) to work on")
                self.parsers["search"] = parser                

        def __LoadFile__(self,filename,items_list):
                """Load File Line By Line"""

                if filename is not None and os.path.exists(filename) and type(items_list) is list:
                        with open(filename,"rt") as f_in:
                                for line in f_in:
                                        line = line.strip()

                                        self.items_list.append(line)

        def LoadExcludes(self,filename):
                """Load Excludes"""

                self.__LoadFile__(filename,self.excludes)

        def LoadPatterns(self,filename):
                """Load Patterns"""

                self.__LoadFile__(filename,self.patterns)

        def Excluded(self,item):
                """Determine if File Is In Excludes"""
        
                flag = False

                if not item == "":
                        abspath=os.path.abspath(item)
                        target=os.path.basename(abspath)

                        if target in self.excludes or item in self.excludes:
                                flag = True

                return flag

        def Overwrite(self,srcEntry,dstEntry):
                """Query User About Overwriting a File"""
        
                bname = os.path.basename(srcEntry[3])
                dstdir = os.path.dirname(dstEntry[3])
                srcdir = os.path.dirname(srcEntry[3])
                Msg("Overwrite {0} in {1} with file from...".format(bname,dstdir))
                response = input("{0} ---> (y/n)? ".format(srcdir))

                return (response == "y" or response == "Y")

        def GetFileInfo(self,filename):
                """Get Timestamp and Size of File"""

                mod_timestamp = None
                fsize = 0

                if os.path.exists(filename):
                        mod_timestamp = datetime.datetime.fromtimestamp(os.path.getmtime(filename))
                
                        fsize = os.path.getsize(filename)

                return [ mod_timestamp, fsize ]

        def IsZeroSize(self,filename):
                """Determine If File is Zero Length"""
        
                info = self.GetFileInfo(filename)

                return (info[1] == 0)

        def CopyFile(self,fname,srcFolder,targetFolder,remove=False):
                """Copy a Given File To A Given Folder"""
        
                fname = os.path.basename(fname)
                tfname = os.path.join(targetFolder,fname)

                if remove and Exists(tfname):
                        os.remove(tfname)

                shutil.copy2(os.path.join(srcFolder,fname),targetFolder,follow_symlinks=False)

        def MoveFile(self,fname,srcFolder,targetFolder,remove=False):
                """Move File from one Location to Another (or Rename)"""
        
                fname = os.path.basename(fname)
                tfname = os.path.join(targetFolder,fname)

                srcFolder = os.path.dirname(srcFolder)
                targetFolder = os.path.dirname(targetFolder)

                if remove and Exists(tfname):
                        os.remove(tfname)

                shutil.move(os.path.join(srcFolder,fname),targetFolder)

        def GetTimeStamp(self,):
                """Get Current Time Stamp"""
        
                return datetime.datetime.now().strftime(self.TimeStampFormat)

        def HasIndex(self,folder):
                """Determine if Folder Has MD5 Index"""

                index = os.path.join(folder,self.FolderIndex)

                return Exists(index)

        def ReportFailedAccess(self,item,prefix=""):
                """Report A Failed Access File To Log"""
        
                if self.access_denied_log is not None:
                        if prefix == "":
                                prefix = "Access denied :"

                        msg = "{0} {1} {2}\n".format(self.GetTimeStamp(),prefix,item)

                        if not self.Silent:
                            Msg(msg)

                        with open(self.access_denied_log,"a") as report:
                                report.write(msg)
        
        def GetFolderContents(self,folder):
                """Get Contents Of Folder"""

                folders = list()
                files = list()

                contents = [ os.path.abspath(folder), folders, files ]

                for item in os.listdir(folder):
                        base = os.path.basename(item)
                        absfolderpath = os.path.abspath(folder)

                        abspath = os.path.join(absfolderpath,base)

                        if os.path.isdir(abspath):
                                folders.append(abspath)
                        elif os.path.isfile(abspath):
                                files.append(abspath)

                return contents

        def ReadTest(self,item):
                """Determine if Supplied File is Readable"""
        
                flag = False

                try:
                        if os.path.exists(item):
                                if os.path.isdir(item):
                                        objects = os.listdir(item)

                                        flag = True
                                else:
                                        with open(item,"r") as data:
                                                flag = True
                except PermissionError:
                        flag = False

                return flag

        def WriteTest(self,item):
                """Determine if Supplied File is Writeable"""
        
                flag = False

                try:
                        if os.path.exists(item):
                                if os.path.isdir(item):
                                        n = TmpFilename(folder=item)
                                        Touch(n)

                                        os.remove(n)
                                        flag = True
                                else:
                                        Touch(item)
                                        flag = True

                except PermissionError:
                        flag = False

                return flag

        def CheckAccess(self,item,mode="rw"):
                """Check R or W or R/W Access to File"""
        
                flag = True

                if "r" in mode:
                        flag = os.access(item,os.R_OK)

                if "w" in mode and flag:
                        flag = os.access(item,os.W_OK)

                return flag

        def SearchEntry(self,entry,field,pattern,escapePattern=False):
                """Search An Entry By Field"""

                result = None

                tmp = entry

                expr = None

                if escapePattern:
                        expr = re.compile(pattern,re.I)
                else:
                        expr = re.compile(pattern)

                if type(entry[0]) is str:
                        tmp = self.ParseHashEntry(entry)

                dentry = self.HashEntryToDict(tmp)

                if field == "date":
                        search_date = datetime.fromisoformat(pattern)
                        
                        if dentry["timestamp"] == search_date:
                                result = entry
                elif field == "size":
                        if dentry["size"] == int(pattern):
                                result = entry
                elif field == "md5" or field == "checksum":
                        if expr.search(dentry["hash"]):
                                result = entry
                elif field == "folder":
                        if expr.search(dentry["filename"]):
                                result = entry
                elif field == "name":
                        fname = os.path.basename(dentry["filename"])

                        if expr.search(fname):
                                result = entry

                return result

        def SearchBuffer(self,buffer,pattern,escapePattern=False):
                """Search A Buffer for a Pattern"""
        
                found = False

                if escapePattern: pattern = re.escape(pattern)

                rexp = re.compile(pattern,re.IGNORECASE)

                result = rexp.search(buffer)

                if not result is None:
                        found = True

                return found

        def Compress(self,uncompressedFilename,compressedFilename,removeOriginal=True,removeArchive=True):
                """Compress File"""
        
                if Exists(compressedFilename) and removeArchive: os.remove(compressedFilename)

                with open(uncompressedFilename,"r") as uncompressedFile, io.TextIOWrapper(gzip.open(compressedFilename,"wb")) as compressedFile:
                        shutil.copyfileobj(uncompressedFile,compressedFile,1024)

                if removeOriginal:
                        os.remove(uncompressedFilename)

        def CompressIndex(self,folder,tmpIndex,removeArchive=True):
                """Compress Index"""
        
                index=os.path.join(folder,self.FolderIndex)

                self.Compress(tmpIndex,index,removeArchive)

        def Decompress(self,compressedFilename,uncompressedFilename,removeArchive=True,mode="w",clearOriginal=False):
                """Decompress File"""
        
                if Exists(uncompressedFilename) and clearOriginal: os.remove(uncompressedFilename)

                with open(uncompressedFilename,mode) as uncompressedFile, io.TextIOWrapper(gzip.open(compressedFilename,"rb")) as compressedFile:
                        shutil.copyfileobj(compressedFile,uncompressedFile,1024)

                if removeArchive:
                        os.remove(compressedFilename)

        def DecompressIndex(self,folder,tmpIndex,removeArchive=True,mode="w",clearOriginal=False):
                """Decompress Index"""
        
                index=os.path.join(folder,self.FolderIndex)

                self.Decompress(index,tmpIndex,removeArchive,mode,clearOriginal)

        def FindIndexes(self,root,depth=-1):
                """Find all Indexes In A Tree"""

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
        
                root, dirs, files = self.GetFolderContents(root)

                if not self.CheckAccess(root):
                        self.ReportFailedAccess(root)
                elif not self.Excluded(root):
                        currentIndex = os.path.join(root,self.FolderIndex)

                        if Exists(currentIndex):
                                Msg(currentIndex)

                        if depth < 0 or depth > 0:
                                depth = depth - 1

                                for subdir in dirs:
                                        self.FindIndexes(subdir,depth)

        def RemoveIndex(self,folder):
                """Remove Index From Supplied Folder"""
        
                currentIndex = os.path.join(folder,self.FolderIndex)

                if os.path.exists(currentIndex):
                        if not self.CheckAccess(currentIndex):
                                self.ReportFailedAccess(currentIndex)
                        else:
                                os.remove(currentIndex)

        def RemoveIndexes(self,root,depth=-1):
                """Remove All Indexes In A Tree"""

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth

                index = f"{root}/{self.FolderIndex}"

                if Exists(index):
                        if not self.CheckAccess(index):
                                self.ReportFailedAccess(index)
                                return

                if not self.Excluded(root):
                        root, dirs, files = self.GetFolderContents(root)

                        self.RemoveIndex(root)

                        if depth < 0 or depth > 0:
                                depth = depth - 1
                                for subdir in dirs:
                                        self.RemoveIndexes(subdir,depth)

        def UncompressedFileSearch(self,filename,pattern,escapePattern=False):
                """Search Uncompressed File For A Pattern"""
        
                found = False

                with open(filename,"r",1048) as data:
                        for line in data:
                                found = self.SearchBuffer(line,pattern,escapePattern)

                                if found: break

                return found

        def CompressedFileSearch(self,archivename,pattern,escapePattern=False):
                """Search A Compressed File for a Pattern"""
        
                found = False

                with io.TextIPWrapper(gzip.open(archivename,"rb",1024)) as archive:
                        for line in archive:
                                found = self.SearchBuffer(line,pattern,escapePattern)

                                if found: break

                return found

        def DumpContents(self,filename):
                """Dump Contents of File To Console"""
        
                rexp = re.compile(r"\.gz$",re.IGNORECASE)
                dataFile = None

                if not rexp.search(filename) is None:
                        dataFile = io.TextIOWrapper(gzip.open(filename,"rb",1024))
                else:
                        dataFile = open(filename,"r",1024)

                rev_line = None
                line_count = 0

                try:
                        for line in dataFile:
                                line_count += 1
                                rev_line = str(line.strip())
                                Msg(rev_line)
                except Exception as err:
                        ErrMsg(err,f"Had a problem reading {filename} at line {line_count} on or before line\n{rev_line}")

                dataFile.close()

        def RemoveIndex(self,folder):
                """Remove Index From Supplied Folder"""

                currentIndex = os.path.join(folder,self.FolderIndex)

                if os.path.exists(currentIndex):
                        if not self.CheckAccess(currentIndex):
                                self.ReportFailedAccess(currentIndex)
                        else:
                                os.remove(currentIndex)

        def RemoveIndexes(self,root,depth=-1):
                """Remove All Indexes In A Tree"""

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
        
                index = f"{root}/{self.FolderIndex}"

                if os.path.exists(index):
                        if not self.CheckAccess(index):
                                self.ReportFailedAccess(index)
                                return

                if not Excluded(root):
                        root, dirs, files = self.GetFolderContents(root)

                        self.RemoveIndex(root)

                        if depth < 0 or depth > 0:
                                depth = depth - 1
                                for subdir in dirs:
                                        self.RemoveIndexes(subdir,depth)

        def HashEntry(self,filename):
                """Create Hash Entry for File"""
        
                entry = None

                filehash = GetMD5Hash(filename)
      
                mod_timestamp, fsize = self.GetFileInfo(filename)

                if (fsize > 0):
                        entry = [ mod_timestamp, fsize, filehash, filename ]

                return entry

        def HashEntryToString(self,entry,newline=False):
                """Convert Hash Entry to String"""
        
                output = "{0} {1} {2} {3}".format(str(entry[0]), str(entry[1]), entry[2], entry[3])

                if newline:
                        output = output + "\n"

                return output

        def HashEntryToMasterEntry(self,prefix,hashEntry):
                """Convert Hash Entry to Master Entry"""
        
                # MasterEntry = [ counter_flag, datetimestamp, fsize, hash, file ]
        
                masterEntry = [ prefix, hashEntry[0], hashEntry[1], hashEntry[2], hashEntry[3] ]

                return masterEntry

        def MasterEntryToHashEntry(self,masterEntry):
                """Convert Master Entry To Hash Entry"""
        
                hashEntry = [ masterEntry[1], masterEntry[2], masterEntry[3], masterEntry[4] ]

                return hashEntry

        def ParseHashEntry(self,hashEntry,folder):
                """Parse Hash Entry"""
        
                # Format of entry
                # [Mod time stamp] [file size] [hash] [file w/full path]
                # Ex.
                # 2018-09-24 11:40:49.954439 783 e532987abda7765c8620875d439dce7b /srv/storage/projects/scripts/filesync/README.md
                # Old format : e532987abda7765c8620875d439dce7b /srv/storage/projects/scripts/filesync/README.md

                # maxsplit = 4, because fnames may contain white space. This will parse date,time,size,hash and dump the remainder as one string
                data = hashEntry.split(" ",4)

                flag = re.match(r"^\d{4}\-\d{2}\-\d{2} \d{2}\:\d{2}\:\d{2}\.\d+ ",hashEntry,re.IGNORECASE)

                if not flag is None:
                        fmt="%Y-%m-%d %H:%M:%S.%f"
                else:
                        fmt="%Y-%m-%d %H:%M:%S"

                mod_timestamp = datetime.datetime.strptime("{0} {1}".format(data[0],data[1]),fmt)

                entry = [ mod_timestamp, int(data[2]), data[3], data[4].strip() ]

                return entry

        def HashEntryToDict(self,entry):
                """Convert Hash Entry to Dictionary"""

                new_entry = { "timestamp" : entry[0], "size" : entry[1], "hash" : entry[2], "filename" : entry[3] }

                return new_entry

        def IsCacheMarker(self,entry):
                """Determine if Line is a Master Cache Marker Line"""
        
                flag = re.match("^from (start|end)",entry,re.IGNORECASE)

                return (not flag == None)

        def IsStartCacheMarker(self,entry):
                """Determines if Line is a Master Cache Start Marker Line"""
        
                flag = re.match("^from start",entry,re.IGNORECASE)

                return (not flag == None)

        def IsEndCacheMarker(self,entry):
                """Determine if Line is a Master Cache End Marker"""
        
                flag = re.match("^from end",entry,re.IGNORECASE)

                return (not flag == None)

        def LoadIndex(self,folder):
                """Load Index"""
        
                entries = list()

                target = os.path.join(folder,self.FolderIndex)

                if Exists(target):
                        try:
                                with io.TextIOWrapper(gzip.open(target,"rb")) as index:
                                        for line in index:
                                                entry = self.ParseHashEntry(str.strip(line),folder)

                                                entries.append(entry)
                        except:
                                os.remove(target)

                return entries

        def SaveIndex(self,entries,folder):
                """Save In Memory Index To File"""
        
                target = os.path.join(folder,self.FolderIndex)

                with io.TextIOWrapper(gzip.open(target,"wb")) as index:
                        for entry in entries:
                                index.write(self.HashEntryToString(entry,True))

        def LoadMasterIndex(self,filename=None):
                """Load Master Index"""
        
                entries = list()

                if filename is None or filename == "":
                        filename = self.Cachefile

                if Exists(filename):
                        folder = ""
                        with open(filename,"r") as masterindex:
                                counter = 0
                                for line in masterindex:
                                        line = line.strip()

                                        if IsStartCacheMarker(line):
                                                folder = line.split(" ",3)[2]

                                        if not IsCacheMarker(line):
                                                entry = ParseHashEntry(line,folder)

                                                masterEntry = HashEntryToMasterEntry(counter,entry)

                                                entries.append(masterEntry)

                                                counter = counter + 1

                return entries

        def FindMatchingEntry(self,index,filename):
                """Find Matching Index Entry In Memory By File Path"""
        
                item = None

                for entry in index:
                        if entry[3] == filename:
                                item = entry
                                break
                return item

        def AddToIndex(self,index,folder,item):
                """Add File Into In Memory Index"""
        
                abspath = os.path.join(folder,item)

                data = self.HashEntry(abspath)

                index.append(data)

        def UpdateFolderIndex(self,folder):
                """Update Folder Index"""
        
                # Operation:
                # If folder is readable and not excluded, process folder
                # If folder does not contain an index, create, otherwise
                # Load the index and compare it with the contents of the folder
                # make changes where appropriate (add, delete, update).
                # Folders with no entries are ignored.
                # MD5 are only checked if the filesize and mod time stamp are
                # different then the recorded ones.
        
                dirs = list()

                if not self.CheckAccess(folder):
                        self.ReportFailedAccess(folder)
                        VerbMsg(f"Access to {folder} denied")
                elif not self.Excluded(folder):
                        root, dirs, files = self.GetFolderContents(folder)

                        if not self.HasIndex(folder) and len(files) > 0:
                                # If no index, and there are files, create index
                                VerbMsg(f"Creating missing index in {folder}")
                                self.CreateIndex(folder)
                        elif self.HasIndex(folder) and len(files) == 0:
                                # If there are no files and there is an index, remove the index.
                                VerbMsg(f"No files in {folder}, removing index")
                                self.RemoveIndex(folder)
                        elif len(files) > 0:
                                # If execution gets here, it implies there is an index and files, so, update
                                removables = list()
                                changes = False

                                VerbMsg(f"Updating index in {folder}")
                                
                                entries = self.LoadIndex(folder)
                                indexFileEntries = list()

                                # Create existence cache and remove non-existent entries
                                for item in entries:
                                        filepath = item[3]

                                        if Exists(filepath):
                                                ts,fsize = self.GetFileInfo(filepath)

                                                if fsize > 0:
                                                        indexFileEntries.append(filepath)
                                                else:
                                                        removables.append(item)
                                        else:
                                                removables.append(item)

                                # Hunt for new and modified files
                                for item in files:
                                        if not self.Excluded(item):
                                                base = os.path.basename(item)
                                                absfolderpath = os.path.abspath(folder)

                                                fp = os.path.join(absfolderpath,base)

                                                mod_timestamp, fsize = self.GetFileInfo(fp)

                                                if not fp in indexFileEntries and fsize > 0:    # New/Add
                                                        changes = True
                                                        self.AddToIndex(entries,absfolderpath,base)
                                                elif fsize > 0:                                 # Check for mods
                                                        entry = self.FindMatchingEntry(entries,fp)

                                                        if not (int(entry[1]) == fsize and entry[0] == mod_timestamp):
                                                                changes = True
                                                                entries.remove(entry)
                                                                self.AddToIndex(entries,absfolderpath,base)

                                # Remove entries marked for deletion
                                for entry in removables:
                                        changes = True
                                        entries.remove(entry)

                                if changes:
                                        self.SaveIndex(entries,folder)

                return dirs

        def UpdateFolderIndexes(self,folder,depth=-1):
                """Update All Folder Indexes In A Tree"""

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
        
                dirs = self.UpdateFolderIndex(folder)

                if depth > -1:
                        depth = depth - 1

                for subdir in dirs:
                        self.UpdateFolderIndexes(subdir, depth)

        def CheckIndex(self,folder):
                '''Check Index and Determine Version'''
        
                ver = 0

                filename = os.path.join(folder,self.FolderIndex)

                if Exists(filename):
                        with io.TextIOWrapper(gzip.open(filename,"rb")) as index:
                                line = index.read()

                                if len(line) > 0:
                                        flag = re.match(r"^[0-9a-z]+\s",line,re.IGNORECASE)

                                        if not flag is None:
                                                ver = 1

                                        flag = re.match(r"^[0-9]{4}\-[0-9]{2}\-[0-9]{2}\s",line,re.IGNORECASE)

                                        if not flag is None:
                                                ver = 2

                                        # If unidentifiable (exits but has no version), flag it
                                        if ver == 0:
                                                ver = -2
                                else:
                                        ver = -3

                return ver

        def ListIndex(self,folder,tmpfile="",mode="w",masterindex=False):
                """List Content of Index In Folder"""
        
                index=os.path.join(folder,self.FolderIndex)

                if Exists(index):
                        if not self.CheckAccess(index,"r"):
                                self.ReportFailedAccess(index)
                        else:
                                if tmpfile == "":
                                        tmpname = TmpFilename(prefix="md5index.listing")
                                else:
                                        tmpname = tmpfile

                                # Prep MasterIndex Items
                                found = False
                                header = "from start {0}\n".format(folder)

                                # Assurance that mode is not set to, or left to default "w" by absentminded programmer
                                if masterindex: mode = "a"

                                # If master index enabled, search master index cache for existing entry
                                if masterindex and Exists(tmpname):
                                        found = self.UncompressedFileSearch(tmpname,"^{0}".format(re.escape(header)))

                                # If masterindex enabled and folder directive is not found, then add marker to master index cache
                                if masterindex and not found:
                                        with open(tmpname,"a") as mi: mi.write(header)

                                # If not masterindex enabled, dump to index file regardless. If masterindex enabled and folder not found, dump index
                                if not masterindex or (masterindex and not found):
                                        self.DecompressIndex(folder,tmpname,False,mode)

                                # If masterindex enabled and not found, add parting marker
                                if masterindex and not found:
                                        with open(tmpname,"a") as mi: mi.write("from end {0}\n".format(folder))

                                if tmpfile == "":
                                        self.DumpContents(tmpname)
                                        os.remove(tmpname)

        def ListIndexes(self,folder,tmpfile="",mode="w",depth=-1,masterindex=False):
                """List Index Contents in Tree"""

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
        
                if not self.CheckAccess(folder,"r"):
                        self.ReportFailedAccess(folder)
                        return

                root, dirs, files = self.GetFolderContents(folder)

                if not self.Excluded(root) and (depth > 0 or depth == -1):
                        self.ListIndex(root,tmpfile,mode,masterindex)

                        if depth > 0:
                                depth = depth - 1

                        for subdir in dirs:
                                self.ListIndexes(subdir,tmpfile,mode,depth,masterindex)

        def MakeMasterIndex(self,folder,filename=None,mode="a",depth=-1):
                """Make Master Index"""

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
        
                if filename is None or filename == "":
                        filename = self.Cachefile

                self.ListIndexes(folder,filename,mode,depth,masterindex=True)

        def RemoveIndexCache(self,filename=""):
                """Remove Index Cache"""
        
                if filename is None or filename == "": filename=self.Cachefile

                if not self.CheckAccess(filename,"w"):
                        self.ReportFailedAccess(filename)
                        return

                if Exists(filename):
                        os.remove(filename)

        def SearchCache(self,searchExpr,outputFilename=None,escapePattern=False,cachefile=None,fieldtype="all"):
                """Search Cache for Expression"""
        
                flag = False

                if cachefile is None:
                        cachefile = self.Cachefile

                for line in open(cachefile,"r"):
                        line = line.strip()

                        if not self.IsCacheMarker(line):
                                if self.SearchBuffer(line,searchExpr,escapePattern):
                                        flag = True

                                        if outputFilename is None:
                                                sys.stdout.write("{0}\n".format(line))
                                        else:
                                                with open(outputFilename,mode) as fp:
                                                        fp.write("{0}\n".format(line))

                return flag

        def SearchFolderIndex(self,folder,searchExpr,outputFilename=None,mode="a",escapePattern=False,fieldtype="all"):
                """Search Folder Index for Expression"""
        
                filePtr = None

                if not self.CheckAccess(folder,"r"):
                        self.ReportFailedAccess(folder)
                        VerbMsg(f"Access for folder {folder} denied")
                elif self.HasIndex(folder):
                        if outputFilename is None:
                                filePtr = sys.stdout
                        else:
                                filePtr = open(outputFilename,mode)

                        entries = self.LoadIndex(folder)

                        VerbMsg(f"Searching {folder}")

                        for entry in entries:
                                if fieldtype == "all":
                                        line = self.HashEntryToString(entry)

                                        if self.SearchBuffer(line,searchExpr,escapePattern):
                                                filePtr.write("{0}\n".format(line))
                                else:
                                        result = self.SearchEntry(entry,fieldtype,searchExpr,escapePattern)

                                        if result is not None:
                                                filePtr.write(f"{result}\n")

                        if not outputFilename is None: filePtr.close()
                else:
                        VerbMsg(f"{folder} does not have an index")

        def SearchFolderIndexes(self,folder,searchExpr,outputFilename=None,mode="a",escapePattern=False,useCache=True,depth=-1,fieldtype="all"):
                """Search Folder Indexes In Tree for Expression"""
        
                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
                        
                if useCache and Exists(self.Cachefile):
                        self.SearchCache(searchExpr,outputFilename,escapePattern,self.Cachefile,fieldtype=fieldtype)
                elif not self.Excluded(folder) and (depth > 0 or depth == -1):
                        self.SearchFolderIndex(folder,searchExpr,outputFilename,mode,escapePattern,fieldtype=fieldtype)

                        root, dirs, files = self.GetFolderContents(folder)

                        if depth > 0:
                                depth = depth - 1

                        for subdir in dirs:
                                self.SearchFolderIndexes(subdir,searchExpr,outputFilename,mode,escapePattern,useCache,depth,fieldtype=fieldtype)

        def FindDuplicates(self,folder,cachename=None,outputFilename=None,mode="a",removeCache=False,depth=-1):
                """Find Duplicates in Tree or Cache"""

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
                        
                outputPtr = None

                if cachename is None or cachename == "":
                        cachename = self.Cachefile

                if outputFilename is None or outputFilename == "":
                        outputPtr = sys.stdout
                else:
                        outputPtr = open(outputFilename,mode)

                if Exists(cachename) and removeCache:
                        self.RemoveCacheIndex(cachename)

                if not Exists(cachename):
                        self.MakeMasterIndex(folder,cachename,depth)

                masterindex = self.LoadMasterIndex(cachename)

                index=0

                for masterEntry in masterindex:
                        for data in masterindex[index:]:
                                if not data[0] == masterEntry[0] and not data[0] == -1:
                                        if data[3] == masterEntry[3] and not data[4] == masterEntry[4]:
                                                data[0] = -1
                                                src = self.MasterEntryToHashEntry(masterEntry)
                                                srcStr = self.HashEntryToString(src)

                                                outputPtr.write("{0} dup {1}\n".format(srcStr,data[4]))

                                index=index+1

        def DeduplicateFolder(self,folder):
                """Deduplicate files and folders in Tree"""
        
                Msg("Not yet implemented")

        def MergeFolders(self,srcFolder,tarFolder,ask=True,movefile=False):
                """Compare Source and Target Folders, Copy or Replace Files in Target Folder"""
        
                srcFolder = os.path.abspath(srcFolder)
                tarFolder = os.path.abspath(tarFolder)

                if self.Excluded(srcFolder) or self.Excluded(tarFolder):
                        return

                if Exists(srcFolder) and Exists(tarFolder):
                        srcRoot, srcdirs, srcfiles = self.GetFolderContents(srcFolder)
                        tarRoot, tardirs, tarfiles = self.GetFolderContents(tarFolder)

                        if not HasIndex(self.srcRoot):
                                self.CreateFolderIndexes(srcRoot)

                        if not self.HasIndex(tarRoot):
                                self.CreateFolderIndexes(tarRoot)

                        saveSrcIndex = False
                        saveTarIndex = False

                        srcIndex = self.LoadIndex(srcRoot)
                        tarIndex = self.LoadIndex(tarRoot)

                        # Files first
                        # if not exists, move to src
                        # if exists, check m5d
                        #       if different and ask = True, ask user what to do Replace() on yes
                        for file in tarfiles:
                                if self.IsZeroSize(file) or self.Excluded(file):
                                        # Skip zero-length files and Excluded files
                                        continue

                                file = os.path.basename(file)

                                tmpsrcFile = os.path.join(srcRoot,file)
                                tarfile = os.path.join(tarRoot,file)

                                # Find Existing Entries
                                srcEntry = self.FindMatchingEntry(srcIndex,tmpsrcFile)
                                tarEntry = self.FindMatchingEntry(tarIndex,tarfile)

                                # If can't find, then create and mark indexes for saving
                                if srcEntry is None and Exists(tmpsrcFile):
                                        srcEntry = self.HashEntry(tmpsrcFile)
                                        srcIndex.append(srcEntry)
                                        saveSrcIndex = True

                                if tarEntry is None:
                                        tarEntry = self.HashEntry(tarfile)
                                        tarIndex.append(tarEntry)
                                        saveTarIndex = True

                                # If Exists, figure out what to do, if not, just copy
                                if Exists(tmpsrcFile):
                                        if srcEntry is None:
                                                Msg("srcEntry is None {0} - {1}".format(tmpsrcFile,srcRoot))
                                        if tarEntry is None:
                                                Msg("tarEntry is None {0}".format(tarfile))

                                        if not srcEntry[2] == tarEntry[2]:
                                                if self.Overwrite(tarEntry,srcEntry):
                                                        if movefile:
                                                                Msg("Replacing {2}/{1} with {0}/{1}".format(tarRoot,file,srcRoot))
                                                                self.MoveFile(file,tarRoot,srcRoot,True)
                                                                tarIndex.remove(tarEntry)
                                                                saveTarIndex = True

                                                                srcIndex.remove(srcEntry)
                                                                srcEntry = tarEntry
                                                                srcEntry[3] = tmpsrcFile
                                                                saveSrcIndex = True
                                                        else:
                                                                Msg("Copying {0}/{1} over {2}/{1}".format(tarRoot,file,srcRoot))
                                                                self.CopyFile(file,tarRoot,srcRoot,True)
                                                                srcEntry = tarEntry
                                                                srcEntry[3] = tmpsrcFile
                                                                saveSrcIndex = True
                                else:
                                        if movefile:
                                                Msg("Moving {0}/{1} to {2}/{1}".format(tarRoot,file,srcRoot))
                                                self.MoveFile(file,tarRoot,srcRoot)
                                                tarIndex.remove(tarEntry)
                                                saveTarIndex = True

                                                srcEntry = tarEntry
                                                srcEntry[3] = tmpsrcFile

                                                srcIndex.append(srcEntry)
                                                saveSrcIndex = True
                                        else:
                                                Msg("Copying {0}/{1} to {2}/{1}".format(tarRoot,file,srcRoot))
                                                self.CopyFile(file,tarRoot,srcRoot)
                                                srcEntry = tarEntry
                                                srcEntry[3] = tmpsrcFile
                                                saveSrvIndex = True

                        # If changes are made, save them
                        if saveSrcIndex:
                                self.SaveIndex(srcIndex,srcRoot)

                        if saveTarIndex:
                                self.SaveIndex(tarIndex,tarRoot)

                        # Garbage collection
                        srcIndex = None
                        tarIndex = None

                        # Dirs
                        # if not exists, copy
                        # if exists, recursive dedup...
                        for dir in tardirs:
                                tdir = os.path.basename(dir)
                                absSrcdir = os.path.join(srcRoot,tdir)
                                absTardir = os.path.join(tarRoot,tdir)

                                if Exists(absSrcdir):
                                        # Recursive dedup
                                        self.MergeFolders(absSrcdir,absTardir,ask,movefile)
                                else:
                                        # copy missing
                                        shutil.copytree(absTardir,absSrcdir,False)
                                        self.UpdateFolderIndexes(absSrcdir)

                else:
                        if not Exists(srcFolder):
                                Msg("{0} does not exist".format(srcFolder))
                        if not Exists(tarFolder):
                                Msg("{0} does not exist".format(tarFolder))

        def CreateIndex(self,folder,files=None):
                """Create Index"""

                # Operation :
                # If the folder is readable, has one or more files, create hash entries
                # of the files that are not excluded.
                # Add hashes to the hash list, when complete, write out the hashes into
                # index in the current folder
        
                entries = list()

                if not self.CheckAccess(folder):
                        self.ReportFailedAccess(folder,"Read/Write Access Denied [CreateIndex] : ")
                        return

                if files is None:
                        root, dirs, files = self.GetFolderContents(folder)

                if len(files) > 0:
                        VerbMsg(f"Processing {folder}")
                        for item in files:
                                target = os.path.join(folder,item)

                                if not self.CheckAccess(target,"r"):
                                        self.ReportFailedAccess(target,"Read denied while building index :")
                                        VerbMsg(f"Read denied on {target}")
                                elif not self.Excluded(target):
                                        hashEntry = self.HashEntry(target)

                                        if not hashEntry is None:
                                                entries.append(hashEntry)
                                                
                        # Save generated hashes into index in current folder
                        self.SaveIndex(entries,folder)
                else:
                        VerbMsg(f"Nothing to process in {folder}")

        def CreateFolderIndexes(self,folder,depth=-1):
                """Create Folder Indexes"""
        
                # Operation:
                # If the folder is not excluded, this function creates an index in the current folder out
                # of the contents found there. If the depth value is anything other then 0, then sub
                # folders are processed by in-order recursive descent.
                # If the depth value is -1, then the function will process the entire sub folder tree,
                # if the value is > 0, then that are 'depth' levels into the folder tree are processed.

                if depth == -1 and self.Depth != -1:
                        depth = self.Depth
        
                folder = os.path.abspath(folder)

                if not Excluded(folder):
                        root, dirs, files = self.GetFolderContents(folder)

                        self.CreateIndex(root,files)

                        if depth < 0 or depth > 0:
                                depth = depth - 1

                                # Process sub folders
                                for subdir in dirs:
                                        self.CreateFolderIndexes(subdir,depth)
                
        def default(self,line):
                """Default Processor Procedure"""
                
                Msg("Who...what... now!!! {0}".format(line))

        def preloop(self):
                """Preloop Procedure"""
                self.prompt = "{0}> ".format(os.path.abspath(os.path.curdir))

        def do_create(self,arguments):
                """Create an index/indexes/cache"""

                args = self.parse(self.parsers["create"],arguments)

                if len(args.folders) == 0:
                        Msg("Using current directory")
                        args.folder.append(os.path.curdir)
                        
                for folder in args.folders:
                        if args.operation == 'index':
                                self.CreateIndex(folder)
                        elif args.operation == 'indexes':
                                self.CreateFolderIndexes(folder)
                        elif args.operation == 'cache':
                                # does not take into account the use of non-default indexes
                                # must fix at some point
                                self.MakeMasterIndex(folder)

        def do_update(self,arguments):
                """Update an index/indexes/cache"""

                args = self.parse(self.parsers["update"],arguments)

                if len(args.folders) == 0:
                        Msg("Using current directory")
                        args.folder.append(os.path.curdir)

                for folder in args.folders:
                        if args.operation == 'index':
                                self.UpdateFolderIndex(folder)
                        elif args.operation == 'indexes':
                                self.UpdateFolderIndexes(folder)
                        elif args.operation == 'cache':
                                self.RemoveIndexCache()
                                self.MakeMasterIndex(folder)

        def do_remove(self,arguments):
                """Remove an index/indexes/cache"""

                args = self.parse(self.parsers["remove"],arguments)
                
                if len(args.folders) == 0:
                        Msg("Using current directory")
                        args.folder.append(os.path.curdir)

                for folder in args.folders:
                        if args.operation == 'index':
                                self.RemoveIndex(folder)
                        elif args.operation == 'indexes':
                                self.RemoveIndexes(folder)
                        elif args.operation == 'cache':
                                # This may execute unnecessarily many times when called and
                                # does not take into account the use of non-default caches
                                # ... must fix at some point
                                self.RemoveIndexCache()

        def do_list(self,arguments):
                """List index/indexes from a folder or tree"""
                
                args = self.parse(self.parsers["list"],arguments)

                if len(args.folders) == 0:
                        Msg("Using current directory")
                        args.folders.append(os.path.curdir)

                for folder in args.folders:
                        if args.operation == 'index':
                                self.ListIndex(folder)
                        elif args.operation == 'indexes':
                                self.ListIndexes(folder)

        def do_find(self,arguments):
                """Find indexes in a folder tree"""
                
                args = self.parse(self.parsers["find"],arguments)

                if len(args.folders) == 0:
                        Msg("Using current directory")
                        args.folders.append(os.path.curdir)

                for folder in args.folders:
                        self.FindIndexes(folder)

        def do_search(self,arguments):
                """Search Through Index/Indexes"""

                args = self.parse(self.parsers["search"],arguments)

                # operation
                # fieldtype
                # searchfor
                # folders

                if len(args.folders) == 0:
                        Msg("Using current directory")
                        args.folders.append(os.path.curdir)

                for folder in args.folders:
                        if args.operation == "index":
                                results = self.SearchFolderIndex(folder,args.searchfor,fieldtype=args.fieldtype)
                        elif args.operation == "indexes":
                                results = self.SearchFolderIndexes(folder,args.searchfor,fieldtype=args.fieldtype)
                        elif args.operation == "cache":
                                ph.NotYetImplemented()

                        if results is not None:
                                for result in results:
                                        Msg(self.HashEntryToString(result))

        def do_ls(self,arguments):
                """Get the directory listing of the current directory"""
                
                for item in os.listdir(os.path.curdir):
                        statinfo = os.stat(item)
                        fileinfo = self.GetFileInfo(item)

                        if os.path.isdir(item):
                                output = "d {0:6} {1:13} {2} {3}".format(statinfo.st_mode,statinfo.st_size,fileinfo[0],item)
                        elif os.path.isfile(item):
                                output = "f {0:6} {1:13} {2} {3}".format(statinfo.st_mode,statinfo.st_size,fileinfo[0],item)
                        elif os.path.islink(item):
                                output = "s {0:6} {1:13} {2} {3}".format(statinfo.st_mode,statinfo.st_size,fileinfo[0],item)

                        Msg(output)

        def do_cd(self,arguments):
                """Change the current directory"""
                
                os.chdir(arguments[0])
                self.prompt = "{0}> ".format(os.path.basename(os.path.curdir))

        def do_cwd(self,arguments):
                """Show current working directory"""
                
                Msg(os.path.abspath(os.curdir))

        def do_more(self,arguments):
                """More a file"""

                for filename in arguments:
                        ph.Pager(filename)

        def do_cat(self,arguments):
                """Cat a file"""

                for filename in arguments:
                        with open(filename,"r") as openfile:
                                for line in openfile:
                                        Msg(line)

        def do_shell(self,arguments):
                """Call shell with supplied arguments"""
                
                output=subprocess.check_output(arguments, shell=True)
                Msg(output)

        def do_quit(self,args):
                """Quit shell"""
                
                Msg("Roger, over and out!")
                
                return True

        def do_exit(self,args):
                """Exit shell"""
                
                Msg("... stage left...")
                
                return True

        def do_bye(self,args):
                """Bye from shell"""
                
                Msg("...bye-eee...")
                
                return True

        def close(self):
                """Close out shell"""
                
                # Self Close (currently not used, potential for debug mode)
                
                self.file = None

        def parse(self,parser,arguments):
                """Parse cmd line"""

                arguments = arguments.split(" ")

                args = parser.parse_args(arguments)
                
                return args

#
# Functions
#

def VerbMsg(msg):
        """Only Print Message When Verbose Flag Is Enabled"""

        global VERBOSE

        if VERBOSE: Msg(msg)

#
# Redis Functions
#

# RemoveFromRedis : Remove Hash From Redis
def RemoveFromRedis(md5sum):
        '''Remove Hash From Redis'''
        
        global objResdis

        if not objRedis is None:
                objRedis.delete(md5sum)

# ExistsIn Redis : Determines If md5sum and/or file exists in Redis DB
def ExistsInRedis(md5sum,fullpath):
        '''Determine if Hash is in Redis DB'''
        
        global objRedis

        flag = -1

        if not objRedis is None:
                flag = objRedis.sismember(md5sum,fullpath)

# InsertRedis : Insert Hash Entry Into Redis Set
def InsertRedis(md5sum, fullpath):
        '''Insert Hash Record Into Redis'''
        
        global objRedis

        flag = ExistsInRedis(md5sum,fullpath)

        if flag > -1:
                flag = objRedis.sismember(md5sum,fullpath)

                objRedis.sadd(md5sum,fullpath)

        return flag

#
# End Redis Functions
#

# LoadRedis : Load indexes into Redis
# Parameters:
# folder        Folder to load into redis cache
def LoadRedis(folder):
        '''Load Redis Index for Folder'''
        
        pass

# RedisDupSearch : Search Redis Cache for Duplicates
# Parameters:
# None
def RedisDupSearch():
        '''Find Dups in Redis Index'''
        
        dups = [ ]
        
        return dups

# ClearRedisCache : Clear Redis Cache
def ClearRedisCache():
        '''Clear Redis Cache'''
        
        pass

# Test Function [INPROGRESS]
# Usage : TestFunc()
def TestFunc(argument):
        '''Test Function'''
        
        global FOLDERINDEX, excludes, patterns, DEBUGFILE, CACHE

        Msg("Running Tests")

        # Rerun index creation, update and masterindex tests

        Msg("Tests completed")

def __Initialize__():
        """Initialize Module"""

        global parser, cmdshell

        parser=argparse.ArgumentParser(description="md5index : Create md5index of contents in folders")
        parser.add_argument("-v","--version",help="Show version",action="store_true")
        parser.add_argument("--verbose",action="store_true",help="When taking actions, be verbose about what is being done")
        parser.add_argument("--cachefile",help="Set cache filename",type=str)
        parser.add_argument("-d","--depth",help="Limit operating tree depth",type=int,default=-1)
        parser.add_argument("-n","--silent",help="Set silent mode",action="store_true")
        parser.add_argument("-e","--excludes",help="Load excludes file",type=str)
        parser.add_argument("-x","--expressions",help="Load expressions file",type=str)
        parser.add_argument("--afl",help="Set access failure log",type=str)
        parser.add_argument("--debug",help="Enter debug mode",action="store_true")
        parser.add_argument("--logfile",help="Set log output filename",type=str)
        parser.add_argument("--redis",help="Connect to redis server",action="store_true")
        parser.add_argument("--shell",help="Invoke shell",action="store_true")
        parser.add_argument("operation",choices=["create","update","search","remove","rm","list","find","merge","cache","rmcache","clear","dup","dedup","loadredis","test"],help="Operation to conduct")
        parser.add_argument("parameters",nargs=argparse.REMAINDER)

        cmdshell = IndexShell()
        
#
# Main Loop
#

__Initialize__()

if __name__ == '__main__':
        '''Main Loop'''
        
        CmdLineMode(True)
        # No log file until asked for
        ph.Logfile = None
        
        args=parser.parse_args()

        # First Process Simple Flags that Terminate Execution Immediately or setup flags for further operations

        DebugMode(args.debug,args.logfile)

        if DebugMode():
                DbgMsg("Entering debugmode")

        DbgMsg("Main Loop : Beginning args parsing")

        if args.version:
                ShowVersion()
                exit(0)

        # Set Operating Flags Next
        DbgMsg("Main Loop : Parsing Operating flags")

        SILENT = cmdshell.Silent = args.silent
        SHELLMODE = args.shell
        DEPTH = cmdshell.Depth = args.depth
        VERBOSE = args.verbose
        cmdshell.Verbose = args.verbose

        # Process Loads of External Data
        DbgMsg("Main Loop : Processing loadables")

        if not args.excludes is None:
                cmdshell.LoadExcludes(args.excludes)
                cmdshell.excludes.extend(excludes)
        if not args.expressions is None:
                cmdshell.LoadPatterns(args.expressions)
        if not args.afl is None:
                cmdshell.access_denied_log = args.afl
        if not args.cachefile is None:
                cmdshell.Cachefile = args.cachefile

        # If Redis is enabled
        if args.redis:
            try:
                objRedis = redis.Redis(host=redisHost,port=redisPort,db=redisDB)
            except:
                DbgMsg("Failed to connect to redis server")
                Msg("Failed to connect to redis server")

        DbgMsg("Main Loop : Parsing action flags")

        if (len(args.parameters) == 0): args.parameters.append(".")
        
        if args.operation == "create":
                cmdshell.onecmd("create " + " ".join(args.parameters))
        elif args.operation == "update":
                cmdshell.onecmd("update " + " ".join(args.parameters))
        elif args.operation == "search":
                cmdshell.onecmd("search " + " ".join(args.parameters))
        elif args.operation == "remove" or args.operation == "rm":
                cmdshell.onecmd("remove " + " ".join(args.parameters))
        elif args.operation == "list":
                cmdshell.onecmd("list " + " ".join(args.parameters))
        elif args.operation == "find":
                cmdshell.onecmd("find " + " ".join(args.parameters))
        elif args.operation == "cache":
                cmdshell.onecmd("cache " + " ".join(args.parameters))
                #for folder in args.parameters:
                #        MakeMasterIndex(folder,depth=DEPTH)
        elif args.operation == "rmcache":
                RemoveIndexCache()
        elif args.operation == "dup":
                for folder in args.parameters:
                        FindDuplicates(folder)
        elif args.operation == "loadredis":
                # Load indexes, add them to redis instance
                # then hunt for duplicates.
                for folder in args.parameters:
                        LoadRedis(folder)

                duplicates = RedisDupSearch()

                # RemoveDuplicates(duplicates,preserve_patterns)

                ClearRedisCache()
        elif args.operation == "dedup":
                DeduplicateFolder(args.parameters)
        elif args.operation == "merge":
                if len(args.parameters) > 1:
                        MergeFolders(args.parameters[0],args.parameters[1],REMOVEFLAG)
        elif args.operation == "clear":
                if Exists(ACCESSDENIEDLOG): os.remove(ACCESSDENIEDLOG)
                if Exists(DEBUGFILE): os.remove(DEBUGFILE)
        elif args.operation == "test":
                for folder in args.parameters:
                        TestFunc(folder)

        DbgMsg("Finished processing args")

        if SHELLMODE:
                DbgMsg("Entering Shell")
                #InteractiveShell
                IndexShell().cmdloop()
                DbgMsg("Exitting Shell")


