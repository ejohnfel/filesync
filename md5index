#!/usr/bin/python3
import io
import os
import gzip
import sys
import datetime
import random
import string
import shutil
import subprocess
import argparse
import re
import cmd
import shlex

'''
Classes
'''

# Interactive Index Shell Class
class IndexShell(cmd.Cmd):
        intro = 'Welcome to the md5index Shell. Type help or ? for help\n'
        prompt = '> '
        file = None

        '''
        Functions
        search indexes [folder]
        search index [folder]
        dup [folder]
        exclude str [string]|exclude file [file]
        re ex [re]|re file [file]
        debug on|off
        silent on|off
        '''

        # Default processor
        def default(self,line):
                print("Who...what... now!!! {0}".format(line))

        # Pre Loop
        def preloop(self):
                self.prompt = "{0}> ".format(os.path.abspath(os.path.curdir))

        # Create Index/Indexes/Cache
        def do_create(self,args):
                'Create an index/indexes/cache'
                flags = self.parse(args)

                task = flags[0]
                targets = [ ]

                if len(flags) == 1:
                        targets = [ os.path.curdir ]
                else:
                        targets = flags[1:]

                for target in targets:
                        if task == 'index':
                                MkIndex(target)
                        elif task == 'indexes':
                                CreateFolderIndexes(target)
                        elif task == 'cache':
                                # does not take into account the use of non-default indexes
                                # must fix at some point
                                MakeMasterIndex(target)

        # Remove Index/Indexes/Cache
        def do_remove(self,args):
                'Remove an index/indexes/cache'
                flags = self.parse(args)

                task = flags[0]
                targets = [ ]

                if len(args) == 1:
                        targets = [ os.path.curdir ]
                else:
                        targets = args[1:]

                for target in targets:
                        if task == 'index':
                                RemoveIndex(target)
                        elif task == 'indexes':
                                RemoveIndexes(target)
                        elif task == 'cache':
                                # This may execute unnecessarily many times when called and
                                # does not take into account the use of non-default caches
                                # ... must fix at some point
                                RemoveIndexCache()

        # Update Index/Indexes/Cache
        def do_update(self,args):
                'Update an index/indexes/cache'
                flags = self.parse(args)

                task = flags[0]
                targets = [ ]

                if len(flags) == 1:
                        targets = [ os.path.curdir ]
                else:
                        targets = flags[1:]

                for target in targets:
                        if task == 'index':
                                UpdateFolderIndex(target)
                        elif task == 'indexes':
                                UpdateFolderIndexes(target)
                        elif task == 'cache':
                                RemoveIndexCache()
                                MakeMasterIndex(target)

        # List Index/Indexes
        def do_list(self,args):
                'List index/indexes from a folder or tree'
                flags = self.parse(args)

                task = flags[0]
                targets = [ ]

                if len(flags) == 1:
                        targets = [ os.path.curdir ]
                else:
                        targets = flags[1:]

                for target in targets:
                        if task == 'index':
                                ListIndex(target)
                        elif task == 'indexes':
                                ListIndexes(target)

        # Find Indexes
        def do_find(self,args):
                'Find indexes in a folder tree'
                flags = self.parse(args)

                task = flags[0]
                targets = [ ]

                if len(flags) == 1:
                        targets = [ os.path.curdir ]
                else:
                        targets = flags[1:]

                for target in targets:
                        FindIndexes(target)

        # List contents of directory [COMPLETED]
        def do_ls(self,args):
                'Get the directory listing of the current directory'
                for item in os.listdir(os.path.curdir):
                        statinfo = os.stat(item)
                        fileinfo = GetFileInfo(item)

                        if os.path.isdir(item):
                                output = "d {0:6} {1:13} {2} {3}".format(statinfo.st_mode,statinfo.st_size,fileinfo[0],item)
                        elif os.path.isfile(item):
                                output = "f {0:6} {1:13} {2} {3}".format(statinfo.st_mode,statinfo.st_size,fileinfo[0],item)
                        elif os.path.islink(item):
                                output = "s {0:6} {1:13} {2} {3}".format(statinfo.st_mode,statinfo.st_size,fileinfo[0],item)

                        print(output)

        # Change Folder [COMPLETED]
        def do_cd(self,args):
                'Change the current directory'
                os.chdir(args[0])
                self.prompt = "{0}> ".format(os.path.basename(os.path.curdir))

        # Show current working directory
        def do_cwd(self,args):
                'Show current working directory'
                print(os.path.abspath(os.curdir))

        # More a file
        def do_more(self,args):
                'More a file'
                lines = os.terminal_size[1]

                with open(args[0],"r") as openfile:
                        printline = 1
                        for line in openfile:
                                print(line)
                                printline = printline + 1

                                if printline >= lines:
                                        input("<< more >>")
                                        printline = 1

        # Cat a file
        def do_cat(self,args):
                'Cat a file'
                with open(args[0],"r") as openfile:
                        for line in openfile:
                                print(line)

        # Shell Sequence
        def do_shell(self,args):
                'Call shell with supplied arguments'
                output=subprocess.check_output(args, shell=True)
                print(output)

        # Terminator Functions [COMPLETED]
        def do_quit(self,args):
                'Quit shell'
                print("Roger, over and out!")
                return True

        def do_exit(self,args):
                'Exit shell'
                print("... stage left...")
                return True

        def do_bye(self,args):
                'Bye from shell'
                print("...bye-eee...")
                return True

        # Self Close (currently not used, potential for debug mode)
        def close(self):
                'Close out shell'
                self.file = None

        # Parse Args into Tuple [COMPLETED]
        def parse(self,args):
                'Parse cmd line'
                return tuple(map(str, args.split()))

'''
Index format
Last_Mod_Timestamp last_size_in_bytes md5hash filename

Master Index Format
Same as Index format, except, the start of each added index includes a index marker of the following format.

from [start|end] path_where_index_came_from
'''

random.seed()

VERMAJ="0"
VERMIN="2ep"
HASENTRYVERSION=2
TIMESTAMPFORMAT="%c"
TIMESTAMP=datetime.datetime.now().strftime(TIMESTAMPFORMAT)
DEBUG=False
DEBUGFILE="/tmp/md5index.debug"
ACCESSDENIEDLOG="/tmp/md5index.access.denied"
VERBOSE=False
FOLDERINDEX=".md5index.gz"
MODE="search"
SILENT=False
SHELLMODE=False
REMOVEFLAG=False
DEPTH=-1
BUILDINDEX=0
TMPCACHE="/tmp/md5index.tmp.cache." + str(random.randint(0,65535))
CACHE="/tmp/md5index.cache"
IGNORECACHE=False
CONVERTFROM=1
CONVERTTO=2

excludes = [ FOLDERINDEX, ".git", ".compiz", ".config", ".dbus", ".gconf", ".gnome2", ".gnome2_private", ".gvfs", ".hplip", ".local", ".salt", ".ssh", "System Volume Information", r"lost+found", r"$RECYCLE.BIN" ]
patterns = [ ]

# ShowVersion : Show Version Information [COMPLETED/Tested]
# Usage : ShowVersion()
def ShowVersion():
	print("Version " + VERMAJ + "." + VERMIN)

# ShellUsage : Show Shell Commands and Usage [INPROGRESS]
# Usage : ShellUsage
def ShellUsage():
	print("Shell Usage (" + VERMAJ + "." + VERMIN + ")")
	print("===================")
	print("create [folder]\t\t\tCreate index in supplied folder, otherwise in current folder")
	print("update [folder]\t\t\tUpdate index in supplied folder, otherwise in current folder")
	print("remove [folder]\t\t\tRemove indexes from supplied folder tree, otherwise from current folder tree")
	print("search [folder] [pattern]\tSearch indexes for pattern, if folder is not supplied, use current")
	print("cache [folder]\t\t\tBuild a cache from the indexes in the folder structure")
	print("rmcache\t\t\tRemove master index cache")
	#print("rmi [file]\t\t\tRemove file and update index]")
	#print("mvi [file] [dest]\t\tMove file, update source and destination indexes")
	#print("cpi [file] [dest]\t\tCopy file, update destination index")
	print("help\t\t\t\tThis message")
	print("quit|exit\t\t\tExit shell")


# DebugMsg : Print a debugging message (and print to log) [COMPLETED/Tested]
# Usage : DebugMsg(message,includetimestamp)
def DebugMsg(message,includetimestamp=True):
        global DEBUG, DEBUGFILE, SILENT

        TIMESTAMP=GetTimeStamp()

        if not includetimestamp:
                MSG=message
        else:
                MSG=TIMESTAMP + " " + message

        if DEBUG:
                if not SILENT: print(MSG)
                with open(DEBUGFILE,"a") as log:
                        log.write("{0}\n".format(MSG))

# Overwrite : Ask user if overwriting a destination is ok
def Overwrite(srcEntry,dstEntry):
        DebugMsg("Entering OverWrite")
        
        bname = os.path.basename(srcEntry[3])
        dstdir = os.path.dirname(dstEntry[3])
        srcdir = os.path.dirname(srcEntry[3])
        print("Overwrite {0} in {1} with file from...".format(bname,dstdir))
        response = input("{0} ---> (y/n)? ".format(srcdir))
        
        return (response == "y" or response == "Y")

# GetTimeStamp : Get properly formatted time stamp [COMPLETED/Tested]
def GetTimeStamp():
        global TIMESTAMPFORMAT

        return datetime.datetime.now().strftime(TIMESTAMPFORMAT)

# TmpFilename : Generate Temp Filename [COMPLETED/Tested]
def TmpFilename(targetDir="/tmp", prefix="md5index.tmp"):
        flag = True

        while flag:
                randomExt = str(random.randint(0,65535))
                tmpname = "{0}/{1}.{2}".format(targetDir,prefix,randomExt)

                if not Exists(tmpname):
                        flag = False

        return tmpname

# Touch : Create a file or zero length, or update a mod timestamp
def Touch(item):
        DebugMsg("Entering Touch({0})".format(item))
        
        data = open(item,"a")

        data.close()

# ReadTest : Read Test or File or Folder
def ReadTest(item):
        DebugMsg("Entering ReadTest({0})".format(item))
        
        flag = False

        try:
                if os.path.exists(item):
                        if os.path.isdir(item):
                                objects = os.listdir(item)

                                flag = True
                        else:
                                with open(item,"r") as data:
                                        flag = True
        except PermissionError:
                flag = False

        return flag

# WriteTest : Write Test on File or Folder
def WriteTest(item):
        DebugMsg("Entering WriteTest({0})".format(item))
        
        flag = False

        try:
                if os.path.exists(item):
                        if os.path.isdir(item):
                                n = TmpFilename(item)
                                Touch(n)

                                os.remove(n)
                                flag = True
                        else:
                                Touch(item)
                                flag = True

        except PermissionError:
                flag = False

        return flag

# CheckAccess : Check access to named item
def CheckAccess(item,mode="rw"):
        DebugMsg("Entering CheckAccess({0})".format(item))
        
        flag = True

        if "r" in mode:
                flag = ReadTest(item)

        if "w" in mode and flag:
                flag = WriteTest(item)

        return flag

# GetFileInfo : Get pertinant file info [COMPLETED/Tested]
def GetFileInfo(filename):
        mod_timestamp = datetime.datetime.fromtimestamp(os.path.getmtime(filename))
        fsize = os.path.getsize(filename)

        return [ mod_timestamp, fsize ]

# IsZeroSize : Check file for zero-length
def IsZeroSize(filename):
        info = GetFileInfo(filename)

        return (info[1] == 0)

# CopyFile : Copy a file from one folder to another
def CopyFile(fname,srcFolder,targetFolder,remove=False):
        DebugMsg("Entering CopyFile({0} from {1} to {2})".format(fname,srcFolder,targetFolder))

        fname = os.path.basename(fname)
        tfname = os.path.join(targetFolder,fname)

        if remove and Exists(tfname):
                os.remove(tfname)
        
        shutil.copy2(os.path.join(srcFolder,fname),targetFolder,follow_symlinks=False)

# MoveFile : Move a file from one folder to another
def MoveFile(fname,srcFolder,targetFolder,remove=False):
        DebugMsg("Entering MoveFile({0})".format(fname))
        
        fname = os.path.basename(fname)
        tfname = os.path.join(targetFolder,fname)

        srcFolder = os.path.dirname(srcFolder)
        targetFolder = os.path.dirname(targetFolder)
        
        if remove and Exists(tfname):
                os.remove(tfname)

        shutil.move(os.path.join(srcFolder,fname),targetFolder)

# GetFolderContents : Get Folder Contents [COMPLETED/Tested]
def GetFolderContents(folder):
        DebugMsg("Entering GetFolderContents({0})".format(folder))
        
        folders = [ ]
        files = [ ]

        contents = [ os.path.abspath(folder), folders, files ]

        for item in os.listdir(folder):
                base = os.path.basename(item)
                absfolderpath = os.path.abspath(folder)

                abspath = os.path.join(absfolderpath,base)

                if os.path.isdir(abspath):
                        folders.append(abspath)
                elif os.path.isfile(abspath):
                        files.append(abspath)

        return contents

# Exists : Check to see if file or folder exists [COMPLETED/Tested]
# Usage : Exists(file|folder path)
def Exists(item):
        return os.path.exists(item)

# HasIndex : Determine folder folder has an index
def HasIndex(folder):
        global FOLDERINDEX

        DebugMsg("Entering HasIndex({0})".format(folder))

        index = os.path.join(folder,FOLDERINDEX)

        return Exists(index)

# Report A Failed Access
def ReportFailedAccess(item,prefix=""):
        global ACCESSDENIEDLOG

        DebugMsg("Reporting Failed Access({0})".format(item))

        if prefix == "":
                prefix = "Access denied :"

        with open(ACCESSDENIEDLOG,"a") as report:
                report.write("{0} {1} {2}\n".format(GetTimeStamp(),prefix,item))

# LoadExpressions : Load Search Expressions [COMPLETED/Tested]
# Usage : LoadExpressions(filename)
def LoadExpressions(filename):
        global patterns

        with open(filename,"r") as patternFile:
                for line in patternFile:
                        patterns.append(line.rstrip())

# LoadExcludes : Load files/folders to exclude [COMPLETED/Tested]
# Usage : LoadExcludes(filename)
def LoadExcludes(filename):
        global excludes

        with open(filename,"r") as excludeFile:
                  for line in excludeFile:
                          excludes.append(line.rstrip())

# Excluded : Check item against Exclude List [COMPLETED/Tested]
# Usage : Excluded(item)
def Excluded(item):
        global excludes

        flag = False

        if not item == "":
                abspath=os.path.abspath(item)
                target=os.path.basename(abspath)

                if target in excludes or item in excludes:
                        flag = True

        return flag

# SearchBuffer : Search a buffer for a pattern [COMPLETED/Tested]
def SearchBuffer(buffer,pattern,escapePattern=False):
        found = False

        if escapePattern: pattern = re.escape(pattern)

        rexp = re.compile(pattern,re.IGNORECASE)

        result = rexp.search(buffer)

        if not result is None:
                found = True

        return found

# UncompressedFileSearch : Search uncompressed file for pattern [COMPLETED/Tested]
def UncompressedFileSearch(filename,pattern,escapePattern=False):
        found = False

        with open(filename,"r",1048) as data:
                for line in data:
                        found = SearchBuffer(line,pattern,escapePattern)

                        if found: break

        return found

# CompressedFileSearch : Search compressed file for pattern [COMPLETED/Tested]
def CompressedFileSearch(archivename,pattern,escapePattern=False):
        found = False

        with io.TextIPWrapper(gzip.open(archivename,"rb",1024)) as archive:
                for line in archive:
                        found = SearchBuffer(line,pattern,escapePattern)

                        if found: break

        return found

# DumpContents : Dump contents of file to console [COMPLETED/Tested]
def DumpContents(filename):
        rexp = re.compile(".gz$",re.IGNORECASE)
        dataFile = None

        if not rexp.search(filename) is None:
                dataFile = io.TextIOWrapper(gzip.open(filename,"rb",1024))
        else:
                dataFile = open(filename,"r",1024)

        for line in dataFile:
                print(str.strip(line))

        dataFile.close()

# Compress : Compress File [COMPLETED/Tested]
def Compress(uncompressedFilename,compressedFilename,removeOriginal=True,removeArchive=True):
        if Exists(compressedFilename) and removeArchive: os.remove(compressedFilename)

        with open(uncompressedFilename,"r") as uncompressedFile, io.TextIOWrapper(gzip.open(compressedFilename,"wb")) as compressedFile:
                shutil.copyfileobj(uncompressedFile,compressedFile,1024)

        if removeOriginal:
                os.remove(uncompressedFilename)

# CompressIndex : Compress Index in Supplied Folder [COMPLETED/Tested]
def CompressIndex(folder,tmpIndex,removeArchive=True):
        global FOLDERINDEX

        index=os.path.join(folder,FOLDERINDEX)

        Compress(tmpIndex,index,removeArchive)

# Decompress : Decompress File [COMPLETED/Tested]
def Decompress(compressedFilename,uncompressedFilename,removeArchive=True,mode="w",clearOriginal=False):
        if Exists(uncompressedFilename) and clearOriginal: os.remove(uncompressedFilename)

        with open(uncompressedFilename,mode) as uncompressedFile, io.TextIOWrapper(gzip.open(compressedFilename,"rb")) as compressedFile:
                shutil.copyfileobj(compressedFile,uncompressedFile,1024)

        if removeArchive:
                os.remove(compressedFilename)

# DecompressIndex : Decompress Index in Supplied Folder [COMPLETED/Tested]
def DecompressIndex(folder,tmpIndex,removeArchive=True,mode="w",clearOriginal=False):
        global FOLDERINDEX

        index=os.path.join(folder,FOLDERINDEX)

        Decompress(index,tmpIndex,removeArchive,mode,clearOriginal)

# FindIndexes : Find All Indexes in a given folder tree [COMPLETED/Tested]
# Usage : FindIndexes(root)
def FindIndexes(root,depth=-1):
        global FOLDERINDEX

        root, dirs, files = GetFolderContents(root)

        if not CheckAccess(root):
                ReportFailedAccess(root)
        elif not Excluded(root):
                currentIndex = os.path.join(root,FOLDERINDEX)

                if Exists(currentIndex):
                        print(currentIndex)

                if depth < 0 or depth > 0:
                        depth = depth - 1

                        for subdir in dirs:
                                FindIndexes(subdir,depth)

# RemoveIndex : Remove Index From Supplied Folder (if it exists) [COMPLETED/Tested]
def RemoveIndex(folder):
        global FOLDERINDEX

        currentIndex = os.path.join(folder,FOLDERINDEX)

        if not CheckAccess(currentIndex):
                ReportFailedAccess(currentIndex)
        elif Exists(currentIndex):
                os.remove(currentIndex)

# RemoveIndexes : Remove All Indexes [COMPLETED/Tested]
def RemoveIndexes(root,depth=-1):
        if not CheckAccess(root):
                ReportFailedAccess(root)
                return

        if not Excluded(root):
                root, dirs, files = GetFolderContents(root)

                RemoveIndex(root)

                if depth < 0 or depth > 0:
                        depth = depth - 1
                        for subdir in dirs:
                                RemoveIndexes(subdir,depth)

        DebugMsg("Entering Remove Indexes")

# MD5Hash : Get MD5 Hash of file [COMPLETED/Tested]
def MD5Hash(filename):
        DebugMsg("Entering MD5Hash : {0}".format(filename))
        
        cmd = "md5sum {0}".format(shlex.quote(filename))

        output=subprocess.check_output(cmd, shell=True)

        return output.split()[0]

# HashEntrySet : Create a HashEntry for a list []
def HashEntry(filename):
        DebugMsg("Entering HashEntry({0})".format(filename))
        
        entry = None
        
        filehash = MD5Hash(filename)
        mod_timestamp, fsize = GetFileInfo(filename)

        if (fsize > 0):
                entry = [ mod_timestamp, fsize, filehash, filename ]

        return entry

# HashEntryToString : Convert HashEntry to string (useful for searches) [COMPLETED/Tested]
def HashEntryToString(entry,newline=False):
        output = "{0} {1} {2} {3}".format(str(entry[0]), str(entry[1]), entry[2], entry[3])

        if newline:
                output = output + "\n"

        return output

# HashEntryToMasterEntry : Convert HashEntry To MasterEntry
def HashEntryToMasterEntry(prefix,hashEntry):
        # MasterEntry = [ counter_flag, datetimestamp, fsize, hash, file ]

        masterEntry = [ prefix, hashEntry[0], hashEntry[1], hashEntry[2], hashEntry[3] ]

        return masterEntry

# MasterEntryToHashEntry : Convert MasterIndex Entry to HashEntry
def MasterEntryToHashEntry(masterEntry):
        hashEntry = [ masterEntry[1], masterEntry[2], masterEntry[3], masterEntry[4] ]

        return hashEntry

# UpgradeOldHashEntry : Upgrade an old Hash Entry to the new form
def UpgradeOldHashEntry(data,folder):
        columns = data.split(" ",2)
        checksum = columns[0]
        filename = os.path.join(folder,columns[1])
        mod_timestamp, fsize = GetFileInfo(filename)

        hashEntry = "{0} {1} {2} {3}".format(mod_timestamp,fsize,checksum,filename)

        return [ hashEntry, hashEntry.split(" ",4) ]

# ParseHashEntry : Parse Hash Entry into Tuple [COMPELTED/Tested]
def ParseHashEntry(hashEntry,folder):
        # Format of entry
        # [Mod time stamp] [file size] [hash] [file w/full path]
        # Ex.
        # 2018-09-24 11:40:49.954439 783 e532987abda7765c8620875d439dce7b /srv/storage/projects/scripts/filesync/README.md
        # Old format : e532987abda7765c8620875d439dce7b /srv/storage/projects/scripts/filesync/README.md

        # maxsplit = 4, because fnames make contain white space. This will parse date,time,size,hash and dump the remainder as one string
        data = ""

        # Check for old Entry
        flag = re.match(r"^[a-f0-9]{26,40}\s",hashEntry,re.IGNORECASE)

        if not flag is None:
                hashEntry, data = UpgradeOldHashEntry(hashEntry,folder)
        else:
                data = hashEntry.split(" ",4)

        flag = re.match(r"^\d{4}\-\d{2}\-\d{2} \d{2}\:\d{2}\:\d{2}\.\d+ ",hashEntry,re.IGNORECASE)

        if not flag is None:
                fmt="%Y-%m-%d %H:%M:%S.%f"
        else:
                fmt="%Y-%m-%d %H:%M:%S"

        mod_timestamp = datetime.datetime.strptime("{0} {1}".format(data[0],data[1]),fmt)

        entry = [ mod_timestamp, data[2], data[3], data[4].strip() ]

        return entry

# IsCacheMarker : Determines if line is a master cache marker line [COMPLETED/Tested]
def IsCacheMarker(entry):
        flag = re.match("^from (start|end)",entry,re.IGNORECASE)

        return (not flag == None)

# IsStartCacheMarker : Determines if line is a master cache start marker line [COMPLETED/Tested]
def IsStartCacheMarker(entry):
        flag = re.match("^from start",entry,re.IGNORECASE)

        return (not flag == None)

# IsEndCacheMarker : Determines if line is a master cache end marker line [COMPLETED/Tested]
def IsEndCacheMarker(entry):
        flag = re.match("^from end",entry,re.IGNORECASE)

        return (not flag == None)

# LoadIndex : Load an index into memory [COMPLETED/Tested]
def LoadIndex(folder):
        global FOLDERINDEX

        DebugMsg("Entering LoadIndex({0})".format(folder))

        entries = [ ]

        target = os.path.join(folder,FOLDERINDEX)

        if Exists(target):
                with io.TextIOWrapper(gzip.open(target,"rb")) as index:
                        for line in index:
                                entry = ParseHashEntry(str.strip(line),folder)

                                entries.append(entry)

        return entries

# SaveIndex : Save in memory index to folder [COMPLETED/Tested]
def SaveIndex(entries,folder):
        global FOLDERINDEX

        DebugMsg("Entering SaveIndex({0})".format(folder))
        
        target = os.path.join(folder,FOLDERINDEX)

        with io.TextIOWrapper(gzip.open(target,"wb")) as index:
                for entry in entries:
                        index.write(HashEntryToString(entry,True))

# LoadMasterIndex : Load Master index into memory [INCOMPLETE/Untested]
def LoadMasterIndex(filename=None):
        global CACHE

        entries = [ ]

        if filename is None or filename == "":
                filename = CACHE

        if Exists(filename):
                folder = ""
                with open(filename,"r") as masterindex:
                        counter = 0
                        for line in masterindex:
                                if IsStartCacheMarker(line):
                                        folder = line.split(" ",3)[2]

                                if not IsCacheMarker(line):
                                        entry = ParseHashEntry(line,folder)

                                        masterEntry = HashEntryToMasterEntry(counter,entry)

                                        entries.append(masterEntry)

                                        counter = counter + 1

        return entries

# MkTmpIndex : Make temporary index (i.e. Uncompressed) [COMPLETED/Tested/OBSOLETE???]
def MkTmpIndex(folder,files,tmpname,mode="w"):
        if len(files) > 0:
                with open(tmpname,mode) as index:
                        for item in files:
                                target = os.path.join(folder,item)

                                index.write(HashEntry(target))

# MkIndex : Make Index [COMPLETE/Tested]
def MkIndex(folder,files=None):
        DebugMsg("Entering MkIndex({0})".format(folder))
        
        entries = [ ]

        if not CheckAccess(folder):
                ReportFailedAccess(folder,"Read/Write Access Denied [MkIndex] : ")
                return

        if files is None:
                root, dirs, files = GetFolderContents(folder)

        if len(files) > 0:
                for item in files:
                        target = os.path.join(folder,item)

                        if not CheckAccess(target,"r"):
                                ReportFailedAccess(target,"Read denied while building index :")
                        elif not Excluded(target):
                                hashEntry = HashEntry(target)

                                if not hashEntry is None:
                                        entries.append(hashEntry)

                SaveIndex(entries,folder)

# CreateFolderIndexes : Create Folder Index(es) [COMPLETE/Tested]
def CreateFolderIndexes(folder,depth=-1):
        DebugMsg("Entering CreateFolderIndexes({0})".format(folder))
        
        folder = os.path.abspath(folder)

        if not CheckAccess(folder):
                ReportFailedAccess(folder,"Read/Write Access Denied [CreateFolderIndexes] : ")
                return

        if not Excluded(folder):
                root, dirs, files = GetFolderContents(folder)

                if len(files) > 0: MkIndex(root,files)

                if depth < 0 or depth > 0:
                        depth = depth - 1

                        for subdir in dirs:
                                CreateFolderIndexes(subdir,depth)

# FindMatchingEntry : Find in memory index entry by file-path
def FindMatchingEntry(index, filename):
        DebugMsg("Entering Find MatchingEntry({0})".format(filename))
        
        item = None

        for entry in index:
                if entry[3] == filename:
                        item = entry
                        break
        return item

# AddToIndex : Add file into in memory index [COMPLETED]
def AddToIndex(index,folder,item):
        DebugMsg("Entering AddToIndex({0})".format(item))
        
        abspath = os.path.join(folder,item)

        data = HashEntry(abspath)

        index.append(data)

# UpdateFolderIndex : Update folder index
def UpdateFolderIndex(folder):
        DebugMsg("Entering UpdateFolderIndex({0})".format(folder))

        dirs = [ ]

        if not CheckAccess(folder):
                ReportFailedAccess(folder)
        elif not Excluded(folder):
                root, dirs, files = GetFolderContents(folder)

                if not HasIndex(folder) and len(files) > 0:
                        MkIndex(folder)
                elif HasIndex(folder) and len(files) == 0:
                        RemoveIndex(folder)
                elif len(files) > 0:
                        removables = [ ]
                        changes = False
                        entries = LoadIndex(folder)
                        indexFileEntries = [ ]
                        
                        # Create existence cache and remove non-existent entries
                        for item in entries:
                                filepath = item[3]
                                ts,fsize = GetFileInfo(filepath)
                                
                                if Exists(filepath) and fsize > 0:
                                        indexFileEntries.append(filepath)
                                else:
                                        removables.append(item)

                        # Hunt for new and modified files
                        for item in files:
                                if not Excluded(item):
                                        base = os.path.basename(item)
                                        absfolderpath = os.path.abspath(root)

                                        fp = os.path.join(absfolderpath,base)

                                        mod_timestamp, fsize = GetFileInfo(fp)

                                        if not fp in indexFileEntries and fsize > 0:  # New/Add
                                                changes = True
                                                AddToIndex(entries,absfolderpath,base)
                                        elif fsize > 0:                           # Check for mods
                                                entry = FindMatchingEntry(entries,fp)
                
                                                if not (int(entry[1]) == fsize and entry[0] == mod_timestamp):
                                                        changes = True
                                                        entries.remove(entry)
                                                        AddToIndex(entries,absfolderpath,base)

                        # Remove entries marked for deletion
                        for entry in removables:
                                changes = True
                                entries.remove(entry)

                        if changes:
                                SaveIndex(entries,absfolderpath)

        return dirs

# UpdateFolderIndexes : Update folder indexes
def UpdateFolderIndexes(folder,depth=-1):
        DebugMsg("Entering UpdateFolderIndexes({0})".format(folder))
        
        dirs = UpdateFolderIndex(folder)

        if depth > -1:
                depth = depth - 1
                
        for subdir in dirs:
                UpdateFolderIndexes(subdir, depth)

# CheckIndex : Open Index and determine version
def CheckIndex(folder):
        global FOLDERINDEX

        DebugMsg("Entering CheckIndex({0})".format(folder))
        
        ver = 0

        filename = os.path.join(folder,FOLDERINDEX)

        if Exists(filename):
                with io.TextIOWrapper(gzip.open(filename,"rb")) as index:
                        line = index.read()

                        if len(line) > 0:
                                flag = re.match(r"^[0-9a-z]+\s",line,re.IGNORECASE)

                                if not flag is None:
                                        ver = 1

                                flag = re.match(r"^[0-9]{4}\-[0-9]{2}\-[0-9]{2}\s",line,re.IGNORECASE)

                                if not flag is None:
                                        ver = 2

                                # If unidentifiable (exits but has no version), flag it
                                if ver == 0:
                                        ver = -2
                        else:
                                ver = -3

        return ver

# ConvertIndexes : Convert v1 to v2 indexes
def ConvertIndexes(folder,oldver=1,newver=2,depth=-1):
        global FOLDERINEX

        DebugMsg("Entering ConvertIndexes({0})".format(folder))

        if not CheckAccess(folder,"r"):
                ReportFailedAccess(folder)
                return
        
        root, dirs, files = GetFolderContents(folder)

        if not Excluded(root) and (depth > 0 or depth == -1):
                pth = os.path.join(folder,FOLDERINDEX)
                
                ver = CheckIndex(root)

                # Currently LoadIndex recognizes v1 and auto-converts to v2
                if ver == oldver:
                        print("Converting {0} to v{1} format".format(pth,newver))
                        index = LoadIndex(folder)
                        SaveIndex(index,folder)
                        
                if depth > 0:
                        depth = depth - 1

                for subdir in dirs:
                        ConvertIndexes(subdir,oldver,newver,depth)

# ListIndexes : List contents of indexes in tree [COMPLETED/Tested]
def ListOldIndexes(folder,vers=-1,depth=-1):
        global FOLDERINDEX
        
        DebugMsg("Entering ListOldIndexes({0})".format(folder))

        if not CheckAccess(folder,"r"):
                ReportFailedAccess(folder)
                return
        
        root, dirs, files = GetFolderContents(folder)

        if not Excluded(root) and (depth > 0 or depth == -1):
                pth = os.path.join(folder,FOLDERINDEX)
                
                ver = CheckIndex(root)

                if vers == -1 or ver == vers:
                        print("ver {0} {1}".format(ver,pth))
                elif ver == -2:
                        print("Unknown {0}".format(pth))
                elif ver == -3:
                        print("Empty {0}".format(pth))
                        
                if depth > 0:
                        depth = depth - 1

                for subdir in dirs:
                        ListOldIndexes(subdir,vers)

# ListIndex : List contents of index in folder [COMPLETED/Tested]
def ListIndex(folder,tmpfile="",mode="w",masterindex=False):
        global FOLDERINDEX

        DebugMsg("Entering ListIndex({0})".format(folder))
        
        index=os.path.join(folder,FOLDERINDEX)

        if Exists(index):
                if not CheckAccess(index,"r"):
                        ReportFailedAccess(index)
                else:
                        if tmpfile == "":
                                tmpname = TmpFilename(prefix="md5index.listing")
                        else:
                                tmpname = tmpfile

                        # Prep MasterIndex Items
                        found = False
                        header = "from start {0}\n".format(folder)

                        # Assurance that mode is not set to, or left to default "w" by absentminded programmer
                        if masterindex: mode = "a"

                        # If master index enabled, search master index cache for existing entry
                        if masterindex and Exists(tmpname):
                                found = UncompressedFileSearch(tmpname,"^{0}".format(re.escape(header)))

                        # If masterindex enabled and folder directive is not found, then add marker to master index cache
                        if masterindex and not found:
                                with open(tmpname,"a") as mi: mi.write(header)

                        # If not masterindex enabled, dump to index file regardless. If masterindex enabled and folder not found, dump index
                        if not masterindex or (masterindex and not found):
                                DecompressIndex(folder,tmpname,False,mode)

                        # If masterindex enabled and not found, add parting marker
                        if masterindex and not found:
                                with open(tmpname,"a") as mi: mi.write("from end {0}\n".format(folder))
                        
                        if tmpfile == "":
                                DumpContents(tmpname)
                                os.remove(tmpname)

        DebugMsg("Exitting ListIndex")
        
# ListIndexes : List contents of indexes in tree [COMPLETED/Tested]
def ListIndexes(folder,tmpfile="",mode="w",depth=-1,masterindex=False):
        DebugMsg("Entering ListIndexes({0})".format(folder))

        if not CheckAccess(folder,"r"):
                ReportFailedAccess(folder)
                return
        
        root, dirs, files = GetFolderContents(folder)

        if not Excluded(root) and (depth > 0 or depth == -1):        
                ListIndex(root,tmpfile,mode,masterindex)

                if depth > 0:
                        depth = depth - 1

                for subdir in dirs:
                        ListIndexes(subdir,tmpfile,mode,depth,masterindex)

# MakeMasterIndex : Make the master index/cache [COMPLETED/Tested]
def MakeMasterIndex(folder,filename=None,mode="a",depth=-1):
        global CACHE

        DebugMsg("Entering MakeMasterIndex({0})".format(folder))

        if filename is None or filename == "":
                filename = CACHE
        
        ListIndexes(folder,filename,mode,depth,masterindex=True)

# RemoveIndexCache : Remove Master Index Cache [COMPLETED/Tested]
# Usage : RemoveIndexCache(filename)
def RemoveIndexCache(filename=""):
        global CACHE

        if filename is None or filename == "": filename=CACHE

        if not CheckAccess(filename,"w"):
                ReportFailedAccess(filename)
                return

        if Exists(filename):
                os.remove(filename)

# SearchFolderIndex : Search Folder Index [COMPLETED/Tested]
def SearchFolderIndex(folder,searchExpr,outputFilename=None,mode="a",escapePattern=False):
        filePtr = None

        if not CheckAccess(folder,"r"):
                ReportFailedAccess(folder)
        elif HasIndex(folder):
                if outputFilename is None:
                        filePtr = sys.stdout
                else:
                        filePtr = open(outputFilename,mode)

                entries = LoadIndex(folder)

                for entry in entries:
                        line = HashEntryToString(entry)

                        if SearchBuffer(line,searchExpr,escapePattern):
                                filePtr.write("{0}\n".format(line))

                if not outputFilename is None: filePtr.close()

# SearchCache : Search Cache File [COMPLETED/Tested]
def SearchCache(searchExpr,outputFilename=None,escapePattern=False,cachefile=None):
        global CACHE

        flag = False
        
        if cachefile is None:
                cachefile = CACHE

        for line in open(cachefile,"r"):
                line = line.strip()
                
                if not IsCacheMarker(line):
                        if SearchBuffer(line,searchExpr,escapePattern):
                                flag = True
                                
                                if outputFilename is None:
                                        sys.stdout.write("{0}\n".format(line))
                                else:
                                        with open(outputFilename,mode) as fp:
                                                fp.write("{0}\n".format(line))

        return flag

# SearchFolderIndexes : Search indexes in a folder tree [COMPLETED/Tested]
def SearchFolderIndexes(folder,searchExpr,outputFilename=None,mode="a",escapePattern=False,useCache=True,depth=-1):
        global CACHE

        if useCache and Exists(CACHE):
                SearchCache(searchExpr,outputFilename,escapePattern,CACHE)
        elif not Excluded(folder) and (depth > 0 or depth == -1):
                SearchFolderIndex(folder,searchExpr,outputFilename,mode,escapePattern)
        
                root, dirs, files = GetFolderContents(folder)

                if depth > 0:
                        depth = depth - 1

                for subdir in dirs:
                        SearchFolderIndexes(subdir,searchExpr,outputFilename,mode,escapePattern,useCache,depth)

# FindDuplicates : Find duplicates in a folder tree (or in cache) [INCOMPLETE/Untested]
def FindDuplicates(folder,cachename=None,outputFilename=None,mode="a",removeCache=False,depth=-1):
        global CACHE

        outputPtr = None
        
        if cachename is None or cachename == "":
                cachename = CACHE

        if outputFilename is None or outputFilename == "":
                outputPtr = sys.stdout
        else:
                outputPtr = open(outputFilename,mode)
                
        if Exists(cachename) and removeCache:
                RemoveCacheIndex(cachename)

        if not Exists(cachename):
                MakeMasterIndex(folder,cachename,depth)

        masterindex = LoadMasterIndex(cachename)

        index=0
                
        for masterEntry in masterindex: 
                for data in masterindex[index:]:
                        if not data[0] == masterEntry[0] and not data[0] == -1:
                                if data[3] == masterEntry[3] and not data[4] == masterEntry[4]:
                                        data[0] = -1
                                        src = MasterEntryToHashEntry(masterEntry)
                                        srcStr = HashEntryToString(src)
                                        
                                        outputPtr.write("{0} dup {1}\n".format(srcStr,data[4]))
                                        
                        index=index+1

# DeduplicateFolder : Deduplicate files and folders in a given folder tree
def DeduplicateFolder(folder):
        print("Not yet implemented")

# MergeFolders : Compare a source folder with a target and copy (or replace) files and folders
def MergeFolders(srcFolder,tarFolder,ask=True,movefile=False):
        DebugMsg("Entering MergeFolders({0},{1})".format(srcFolder,tarFolder))
        
        srcFolder = os.path.abspath(srcFolder)
        tarFolder = os.path.abspath(tarFolder)

        if Excluded(srcFolder) or Excluded(tarFolder):
                return
        
        if Exists(srcFolder) and Exists(tarFolder):
                srcRoot, srcdirs, srcfiles = GetFolderContents(srcFolder)
                tarRoot, tardirs, tarfiles = GetFolderContents(tarFolder)

                if not HasIndex(srcRoot):
                        CreateFolderIndexes(srcRoot)

                if not HasIndex(tarRoot):
                        CreateFolderIndexes(tarRoot)

                saveSrcIndex = False
                saveTarIndex = False
                
                srcIndex = LoadIndex(srcRoot)
                tarIndex = LoadIndex(tarRoot)
                
                # Files first
                # if not exists, move to src
                # if exists, check m5d
                #       if different and ask = True, ask user what to do Replace() on yes
                for file in tarfiles:
                        if IsZeroSize(file) or Excluded(file):
                                # Skip zero-length files and Excluded files
                                continue
                        
                        file = os.path.basename(file)
                        
                        tmpsrcFile = os.path.join(srcRoot,file)
                        tarfile = os.path.join(tarRoot,file)

                        # Find Existing Entries
                        srcEntry = FindMatchingEntry(srcIndex,tmpsrcFile)
                        tarEntry = FindMatchingEntry(tarIndex,tarfile)

                        # If can't find, then create and mark indexes for saving
                        if srcEntry is None and Exists(tmpsrcFile):
                                srcEntry = HashEntry(tmpsrcFile)
                                srcIndex.append(srcEntry)
                                saveSrcIndex = True

                        if tarEntry is None:
                                tarEntry = HashEntry(tarfile)
                                tarIndex.append(tarEntry)
                                saveTarIndex = True

                        # If Exists, figure out what to do, if not, just copy      
                        if Exists(tmpsrcFile):
                                if srcEntry is None:
                                        print("srcEntry is None {0} - {1}".format(tmpsrcFile,srcRoot))
                                if tarEntry is None:
                                        print("tarEntry is None {0}".format(tarfile))

                                DebugMsg("{0} - {1}".format(srcEntry[2],tarEntry[2]))
                                if not srcEntry[2] == tarEntry[2]:
                                        if Overwrite(tarEntry,srcEntry):
                                                if movefile:
                                                        print("Replacing {2}/{1} with {0}/{1}".format(tarRoot,file,srcRoot))
                                                        MoveFile(file,tarRoot,srcRoot,True)
                                                        tarIndex.remove(tarEntry)
                                                        saveTarIndex = True

                                                        srcIndex.remove(srcEntry)
                                                        srcEntry = tarEntry
                                                        srcEntry[3] = tmpsrcFile
                                                        saveSrcIndex = True
                                                else:
                                                        print("Copying {0}/{1} over {2}/{1}".format(tarRoot,file,srcRoot))
                                                        CopyFile(file,tarRoot,srcRoot,True)
                                                        srcEntry = tarEntry
                                                        srcEntry[3] = tmpsrcFile
                                                        saveSrcIndex = True
                        else:
                                if movefile:
                                        print("Moving {0}/{1} to {2}/{1}".format(tarRoot,file,srcRoot))
                                        MoveFile(file,tarRoot,srcRoot)
                                        tarIndex.remove(tarEntry)
                                        saveTarIndex = True

                                        srcEntry = tarEntry
                                        srcEntry[3] = tmpsrcFile

                                        srcIndex.append(srcEntry)
                                        saveSrcIndex = True
                                else:
                                        print("Copying {0}/{1} to {2}/{1}".format(tarRoot,file,srcRoot))
                                        CopyFile(file,tarRoot,srcRoot)
                                        srcEntry = tarEntry
                                        srcEntry[3] = tmpsrcFile
                                        saveSrvIndex = True

                # If changes are made, save them
                if saveSrcIndex:
                        SaveIndex(srcIndex,srcRoot)

                if saveTarIndex:
                        SaveIndex(tarIndex,tarRoot)
                        
                # Garbage collection
                srcIndex = None
                tarIndex = None
                
                # Dirs
                # if not exists, copy
                # if exists, recursive dedup...
                for dir in tardirs:
                        tdir = os.path.basename(dir)
                        absSrcdir = os.path.join(srcRoot,tdir)
                        absTardir = os.path.join(tarRoot,tdir)
                        
                        if Exists(absSrcdir):
                                # Recursive dedup
                                MergeFolders(absSrcdir,absTardir,ask,movefile)
                        else:
                                # copy missing
                                shutil.copytree(absTardir,absSrcdir,False)
                                UpdateFolderIndexes(absSrcdir)

        else:
                if not Exists(srcFolder):
                        print("{0} does not exist".format(srcFolder))
                if not Exists(tarFolder):
                        print("{0} does not exist".format(tarFolder))

'''
# MoveFromFolder :
# Usage : MoveFromFolder [src] [dest]
function MoveFromFolder()
{
	abspaths=$(realpath "${1}")
	parents=$(dirname "${abspaths}")
	filenames=$(basename "${abspaths}")

	abspathd=$(realpath "${2}")
	parentd=$(dirname "${abspathd}")

	mv "${abspaths}" "${abspathd}"

	UpdateIndexes "${abspaths}"
	UpdateIndexes "${abspathd}"
}

# CopyToFolder :
# Usage : CopyToFolder [src] [dest]
function CopyToFolder()
{
	abspaths=$(realpath "${1}")
	parents=$(dirname "${abspaths}")
	filenames=$(basename "${abspaths}")

	abspathd=$(realpath "${2}")
	parentd=$(dirname "${abspathd}")

	cp "${abspaths}" "${abspathd}"

	UpdateIndexes "${abspaths}"
	UpdateIndexes "${abspathd}"
}
'''

# InteractiveShell : Interactive Processing Shell
def InteractiveShell():
        IndexShell().cmdloop()
        
        while False:
                sys.stdout.write("> ")
                cmd = sys.stdin.readline().strip()
                args = cmd.split(" ")

                if len(args) == 1:
                        args.append(".")

                if args[0] == "quit":
                        break
                elif args[0] == "cd":
                        os.chdir(args[1])
                elif args[0] == "create":
                        CreateFolderIndexes(args[1])
                elif args[0] == "update":
                        UpdateFolderIndexes(args[1])
                elif args[0] == "search":
                        SearchFolderIndexes(args[1])
                elif args[0] == "remove":
                        RemoveIndexes(args[1])
                elif args[0] == "list":
                        ListIndexes(args[1])
                elif args[0] == "find":
                        FindIndexes(args[1])
                elif args[0] == "cache":
                        MakeMasterIndex(args[1])
                elif args[0] == "rmcache":
                        RemoveIndexCache(args[1])
                elif args[0] == "dup":
                        FindDuplicates(args[1])
                elif args[0] == "help":
                        ShellUsage()
                elif args[0] == "clear":
                        subprocess.check_output("clear", shell=True)
                        
'''
# Interactive Index Shell
function InteractiveShell()
{
	SHPROMPT="$(pwd)> "

	while read -p "${SHPROMPT}" cmd first second remainder; do
        	case "${cmd}" in
		"usage"|"help")	ShellUsage ;;
		"create")	if [ "${first}" = "" ]; then
					MakeFolderIndexes .
				else
					eval MakeFolderIndexes ${first} ${second} ${remainder}
				fi
				;;
        	"search")	if [ "${second}" = "" -a "${remainder}" = "" ]; then
					eval SearchFolderIndexes . "${first}"
				else
					eval SearchFolderIndexes ${first} ${second} ${remainder}
				fi
				;;
		"update")	if [ "${first}" = "" ]; then
					UpdateFolderIndex .
				else
					eval UpdateFolderIndex ${first} ${second} ${remainder}
				fi
				;;
		"remove")	if [ "${first}" = "" ]; then
					RemoveIndexes .
				else
					eval RemoveIndexes ${first} ${second} ${remainder}
				fi
				;;
		"cache")	if [ "${first}" = "" ]; then
					MakeMasterIndex .
				else
					eval MakeMasterIndex ${first} ${second} ${remainder}
				fi
				;;
		"removecache")	[ -e "${CACHE}" ] && rm "${CACHE}" ;;
		"rmi")		RemoveFromIndex ${first} ${second} ${remainder} ;;
		"mvi")		MoveFromFolder ${first} ${second} ${remainder} ;;
		"cpi")		CopyToFolder ${first} ${second} ${remainder} ;;
		"duplicates")	Duplicates "${first}" "${second}" ${remainder} ;;
        	"quit"|"exit")
                	break ;;
        	*)
                	eval ${cmd} ${first} ${second} ${remainder} ;;
        	esac

        	SHPROMPT="$(pwd)> "
	done
}
'''

# Start Debug Log [COMPLETED/Tested]
def StartDebug():
        global DEBUGFILE
                
        with open(DEBUGFILE,"a") as log:
                log.write("md5index called on {0}\n".format(GetTimeStamp()))

# Close Debug Log [COMPLETED/Tested]
def CloseDebug():
        global DEBUGFILE

        with open(DEBUGFILE,"a") as log:
                log.write("md5index ended on {0}".format(GetTimeStamp()))
                log.flush()

# Test Function [INPROGRESS]
# Usage : TestFunc()
def TestFunc(argument):
        global FOLDERINDEX, excludes, patterns, DEBUGFILE, CACHE
        
        print("Running Tests")

        # Rerun index creation, update and masterindex tests
        
        print("Tests completed")

#
# Main Loop
#

if __name__ == '__main__':

        if Exists(DEBUGFILE): os.remove(DEBUGFILE)

        parser=argparse.ArgumentParser(description="md5index : Create md5index of contents in folders")
        parser.add_argument("-c","--create", help="Create an index",action="store_true")
        parser.add_argument("-u","--update",help="Update an index",action="store_true")
        parser.add_argument("-s","--search",help="Search through index (and tree or cache) [opt-folder] [search expr]",action="store_true")
        parser.add_argument("-r","--remove",help="Remove indexes from tree",action="store_true")
        parser.add_argument("--shell",help="Invoke shell",action="store_true")
        parser.add_argument("-f","--find",help="Find all indexes in tree",action="store_true")
        parser.add_argument("-l","--list",help="List contents of index(es)",action="store_true")
        parser.add_argument("--findv",help="Find indexes and list their versions",action="store_true")
        parser.add_argument("--convert",help="Convert indexes between versions",action="store_true")
        parser.add_argument("--convertf",help="Convert indexes from this version",type=str)
        parser.add_argument("--convertt",help="Convert indexes to this version",type=str)
        parser.add_argument("--dup",help="Find duplicates",action="store_true")
        parser.add_argument("--dedup",help="Deduplicate files/folders in given folder",type=str)
        parser.add_argument("--merge",help="merge one folder into another folders [merge-target] [folder2]",action="store_true")
        parser.add_argument("--remove",help="Set removal flag for operations that move or delete files/folders",action="store_true")
        parser.add_argument("-v","--version",help="Show version",action="store_true")
        parser.add_argument("-t","--test",help="Invoke test function",action="store_true")
        parser.add_argument("--cache",help="Create index cache",action="store_true")
        parser.add_argument("--rmcache",help="Remove index cache",action="store_true")
        parser.add_argument("--cachefile",help="Set cache filename",type=str)
        parser.add_argument("-d","--depth",help="Limit operating tree depth",type=int,default=-1)
        parser.add_argument("-n","--silent",help="Set silent mode",action="store_true")
        parser.add_argument("-e","--excludes",help="Load excludes file",type=str)
        parser.add_argument("-x","--expressions",help="Load expressions file",type=str)
        parser.add_argument("--afl",help="Set access failure log",type=str)
        parser.add_argument("--clear",help="Clear temp and logging files",action="store_true")
        parser.add_argument("--debug",help="Enter debug mode",action="store_true")
        parser.add_argument("--debugfile",help="Set debug output filename",type=str)
        parser.add_argument("folders",nargs=argparse.REMAINDER)

        args=parser.parse_args()

        # First Process Simple Flags that Terminate Execution Immediately

        if DEBUG or args.debug:
                if args.debug:
                        DEBUG=args.debug

                StartDebug()

        DebugMsg("Beginning args parsing")

        if args.version:
                ShowVersion()

        # Set Operating Flags Next
        DebugMsg("Parsing Operating flags")

        SILENT=args.silent
        SHELLMODE=args.shell
        DEPTH=args.depth
        REMOVEFLAG = args.remove

        # Process Loads of External Data
        DebugMsg("Processing loadables")

        if not args.excludes is None:
                LoadExcludes(args.excludes)
        if not args.expressions is None:
                LoadExpressions(args.expr)
        if not args.afl is None:
                ACCESSDENIEDLOG=args.afl
        if not args.cachefile is None:
                CACHE=args.cachefile
        if not args.debugfile is None:
                DEBUGFILE=args.debugfile
        if not args.convertf is None:
                CONVERTFROM=int(args.convertf)
        if not args.convertt is None:
                CONVERTTO=int(args.convertt)
                

        DebugMsg("Parsing action flags")

        if (len(args.folders) == 0): args.folders.append(".")

        if args.create:
                for folder in args.folders:
                        CreateFolderIndexes(folder,DEPTH)
        elif args.update:
                for folder in args.folders:
                        UpdateFolderIndexes(folder,DEPTH)
        elif args.search:
                if len(args.folders) > 1:
                        SearchFolderIndexes(args.folders[0],args.folders[1],depth=DEPTH)
                else:
                        SearchFolderIndexes(".",args.folder[0],dept=DEPTH)
        elif args.remove:
                for folder in args.folders:
                        RemoveIndexes(folder,DEPTH)
        elif args.list:
                for folder in args.folders:
                        ListIndexes(folder,DEPTH)
        elif args.findv:
                for folder in args.folders:
                        ListOldIndexes(folder,1,DEPTH)
        elif args.convert:
                for folder in args.folders:
                        ConvertIndexes(folder,CONVERTFROM,CONVERTTO,depth=DEPTH)
        elif args.find:
                for folder in args.folders:
                        FindIndexes(folder,DEPTH)
        elif args.test:
                for folder in args.folders:
                        TestFunc(folder)
        elif args.cache:
                for folder in args.folders:
                        MakeMasterIndex(folder,depth=DEPTH)
        elif args.rmcache:
                RemoveIndexCache()
        elif args.dup:
                for folder in args.folders:
                        FindDuplicates(folder)
        elif not args.dedup is None:
                DeduplicateFolder(args.dedup)
        elif args.merge:
                if len(args.folders) > 1:
                        MergeFolders(args.folders[0],args.folders[1],REMOVEFLAG)
        elif args.shell:
                SHELLMODE = True
        elif args.clear:
                if Exists(ACCESSDENIEDLOG): os.remove(ACCESSDENIEDLOG)
                if Exists(DEBUGFILE): os.remove(DEBUGFILE)

        DebugMsg("Finished processing args")

        if SHELLMODE:
                DebugMsg("Entering Shell")
                #InteractiveShell
                IndexShell().cmdloop()
                DebugMsg("Exitting Shell")

        if DEBUG:
                DebugMsg("Close Debug Log")
                CloseDebug()

